#   指定activeMQ broker的url，默认自动生成
spring.activemq.broker-url=xx
#   在考虑结束之前等待的时间
spring.activemq.close-timeout=1000
#   默认代理URL是否在内存中，如果指定了显示代理，则忽略此值
spring.activemq.in-memory=false
#   是否在回滚消息之前停止消息传递，这意味着当启用此指令时，消息顺序不会被保留
spring.activemq.non-blocking-redelivery=false
#   是否信任所有包
spring.activemq.packages.trust-all=false
#   指定信任包，多个以半角逗号隔开（仅限于trust-all=false时[当不信任所有包时]）
spring.activemq.packages.trusted=xxx
#   activemq密码
spring.activemq.password=xxx
#   当请求池满时是否启用阻塞模式，设置未false系统将会抛出“JMSException异常”
spring.activemq.pool.block-if-full=false
#   如果请求池依然是满的，则在抛出异常前阻塞时间
spring.activemq.pool.block-if-full-timeout=100
#   是否在启动时创建连接，可以在启动时用于加热池
spring.activemq.pool.create-connection-on-startup=false
#   是否用Pooledconnectionfactory代替普通的ConnectionFactory。
spring.activemq.pool.enabled=false
#   连接过期时间
spring.activemq.pool.expiry-timeout=0
#   连接空闲超时
spring.activemq.pool.idle-timeout=30000
#   连接池最大连接数
spring.activemq.pool.max-connections=1
#   每个连接的有效会话最大数目
spring.activemq.pool.maximum-active-session-per-connection=1
#   当有“JMSException”时重新连接
spring.activemq.pool.reconnect-on-exception=false
#   在空闲连接清除线程之间的时间，当为负数时，没有空闲连接清除线程运行
spring.activemq.pool.time-between-expiration-check=100
#   是否只使用一个MessageProducer
spring.activemq.pool.use-anonymous-producers=false
#   发送超时时间
spring.activemq.send-timeout=10000
#   activemq用户
spring.activemq.user=xx


#   是否自动使用AOP功能，默认值为true
#   其实springboot此配置是默认开启的，所以根本可以不用管了，在Springboot中使用过注解配置方式的人会问是否需要在程序主类中增加@EnableAspectJAutoProxy来启用，实际并不需要。看下面关于AOP的默认配置属性，其中spring.aop.auto属性默认是开启的，也就是说只要引入了AOP依赖后，其实默认已经增加了@EnableAspectJAutoProxy。
spring.aop.auto=false
#   由于博主使用的是Spring Boot 2.0 ，在 Spring Boot 2.0 中，Spring Boot现在默认使用CGLIB动态代理(基于类的动态代理), 包括AOP。 如果需要基于接口的动态代理(JDK基于接口的动态代理) ，需要设置spring.aop.proxy-target-class属性为false。
#   因此在application.properties加上配置spring.aop.proxy-target-class=false。重启访问
spring.aop.proxy-target-class=false
#   是否启用admin特性，默认为false
spring.application.admin.enabled=false
#   指定admin MBean的名称，默认为：org.springframework.boot:type=Admin,name=SpringApplication
spring.application.admin.jmx-name=org.springframework.boot:type=Admin,name=SpringApplication
#   应用程序索引
spring.application.index=1
#   应用程序名称
spring.application.name=app-name
#   集群密码，默认在程序启动时自动生成
spring.artemis.embedded.cluster-password=xxx
#   日志文件目录，如果持久性已关闭则不需要此指令
spring.artemis.embedded.data-directory=xxx
#   如果Artemis服务器API可用，则启用嵌入式模式
spring.artemis.embedded.enabled=false
#   启用持久存储
spring.artemis.embedded.persistent=false
#   在启动时创建的逗号分隔队列列表
spring.artemis.embedded.queues=1
#   服务器ID，默认情况下使用的自动递增计数器
spring.artemis.embedded.server-id=0
#   启动时创建的逗号分隔的主题列表
spring.artemis.embedded.topics=xx
#   artemis代理主机
spring.artemis.host=localhost
#   artemis部署模式，默认情况下自动检测，可现实设置为本机或嵌入
spring.artemis.mode=embedded
# artemis代理密码
spring.artemis.password=password
#   artemis代理端口
spring.artemis.port=61616
#   artemis代理用户名
spring.artemis.user=username
#   要自动配置需要排除的类
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration
#   如果需要，在启动时创建所需的批处理表
spring.batch.initializer.enabled=false
#   在启动时在上下文中执行所有的Spring batch作业
spring.batch.job.enabled=false
#   在启动时执行的作业名的逗号分隔列表（例如job1，job2）。默认情况下，在上下文中找到的所有作业都将被执行。
spring.batch.job.names=names
#   classpath ：org / springframework / batch / core / schema - @@ platform @@。sql＃用于初始化数据库模式的SQL文件的路径。
spring.batch.schema=xxx
#   所有批次元数据表的表前缀
spring.batch.table-prefix=zr_
#   是否跳过搜索BeanInfo类
spring.beaninfo.ignore=false
#   如果底层缓存管理器支持，则创建缓冲区名称的逗号分隔列表
spring.cache.cache-names=cache_names
#   定义的特殊缓存
spring.cache.caffeine.spec=spec
#   条目过期[以毫秒为单位]，默认永不过期
spring.cache.couchbase.expiration=0
#   用户初始化ehcache的配置文件位置
spring.cache.ehcache.config=bootstrap.properties
#   用户初始化infinispan的配置文件位置
spring.cache.infinispan.config=bootstrap.properties
#   用于初始化jcache配置文件的位置
spring.cache.jcache.config=bootstrap.properties
#   用于检索JSR-107的CachingProvider实现的完全限定名称
spring.cache.jcache.provider=xx
#   缓存类型
spring.cache.type=redis
#   在远程配置文件里设置授权，
#   （这个配置不能在本地被设置）。一旦设置了这个权限，你可以配置更加细粒度的配置来配置覆盖的方式，
#   比如：
#- spring.cloud.config.overrideNone=true 覆盖任何本地属性
#- spring.cloud.config.overrideSystemProperties=false 仅仅系统属性和环境变量
#源文件见PropertySourceBootstrapProperties
spring.cloud.config.allow-override=false
#   覆盖任何本地属性
spring.cloud.config.override-none=true
#   仅仅系统属性和环境变量
spring.cloud.config.override-system-properties=false
spring.cloud.discovery.client.simple.instances.xx=xxx
spring.cloud.discovery.client.simple.local.metadata.xx=xx
#   发现客户端简单的本地服务ID
spring.cloud.discovery.client.simple.local.service-id=app-service
#   发现客户端简单的本地服务uri
spring.cloud.discovery.client.simple.local.uri=xxx
#   hypermedia固定延时刷新时间
spring.cloud.hypermedia.refresh.fixed-delay=5000
#   hypermedia初始延时刷新时间
spring.cloud.hypermedia.refresh.initial-delay=10000
#   默认主机名，用于发生错误的情况。
spring.cloud.inetutils.default-hostname=localhost
#   默认ip地址，用于发生错误的情况。
spring.cloud.inetutils.default-ip-address=127.0.0.1
#   将被忽略的网络接口的Java正则表达式列表
spring.cloud.inetutils.ignored-interfaces=xx
#   将被忽略的网络地址的Java正则表达式列表
spring.cloud.inetutils.preferred-networks=xxx
#   计算主机名的超时秒数。
spring.cloud.inetutils.timeout-seconds=1
#   仅使用与站点本地地址的接口。有关详细信息，请参阅{@link InetAddress＃isSiteLocalAddress（）}。
spring.cloud.inetutils.use-only-site-local-interfaces=false
#   负载均衡是否启用
spring.cloud.loadbalancer.retry.enabled=true
#   是否开启服务自动注册
spring.cloud.service-registry.auto-registration.fail-fast=true
#   配置文件位置
spring.config.location=/
#   配置文件名称[默认为application]
spring.config.name=application
#   Couchbase节点（主机或IP地址）从中引导。
spring.couchbase.bootstrap-hosts=localhost
#   要连接到的桶的名称
spring.couchbase.bucket.name=default
#   桶的密码
spring.couchbase.bucket.password=password
#   针对Key / Value服务的每个节点的套接字数。
spring.couchbase.env.endpoints.key-value=1
#   针对Query（N1QL）服务的每个节点的套接字数。
spring.couchbase.env.endpoints.query=1
#   针对视图服务的每个节点的套接字数。
spring.couchbase.env.endpoints.view=1
#   启用SSL支持。如果提供“keyStore”，则自动启用，除非另有规定。
spring.couchbase.env.ssl.enabled=true
#   保存证书的JVM密钥存储库的路径
spring.couchbase.env.ssl.key-store=/
#   用于访问密钥库的密码
spring.couchbase.env.ssl.key-store-password=password
#   桶连接超时（以毫秒为单位）。
spring.couchbase.env.timeouts.connect=5000
#   以特定密钥超时（以毫秒为单位）执行封锁操作。
spring.couchbase.env.timeouts.key-value=2500
#   N1QL查询操作超时（以毫秒为单位）
spring.couchbase.env.timeouts.query=7500
#   套接字连接连接超时（以毫秒为单位）
spring.couchbase.env.timeouts.socket-connect=1000
#   正常和地理空间视图操作超时（以毫秒为单位
spring.couchbase.env.timeouts.view=7500
#   启用PersistenceExceptionTranslationPostProcessor。
spring.dao.exceptiontranslation.enabled=true
#   Cassandra群集的名称
spring.data.cassandra.cluster-name=cluster-name
#   由Cassandra二进制协议支持的压缩
spring.data.cassandra.compression=none
#   套接字选项：连接超时。
spring.data.cassandra.connect-timeout-millis=100000
#   查询一致性级别
spring.data.cassandra.consistency-level=debug
#   集群节点地址的逗号分隔列表。
spring.data.cassandra.contact-points=localhost
#   查询默认的抓取大小。
spring.data.cassandra.fetch-size=1000
#   要使用的密钥空间名称
spring.data.cassandra.keyspace-name=name
#   负载均衡策略的类名。
spring.data.cassandra.load-balancing-policy=true
#   登录服务器的密码
spring.data.cassandra.password=password
#   登录服务器端口
spring.data.cassandra.port=6600
#   读取超时时间，套接字选项：读取超时。
spring.data.cassandra.read-timeout-millis=100000
#   重新连接策略类
spring.data.cassandra.reconnection-policy=policy
#   是否启用Cassandra存储库。
spring.data.cassandra.repositories.enabled=true
#   重试策略的类名
spring.data.cassandra.retry-policy=policy
#   启动时采取的模式操作
spring.data.cassandra.schema-action=none
#   查询串行一致性级别。
spring.data.cassandra.serial-consistency-level=debug
#   启用SSL支持。
spring.data.cassandra.ssl=false
#   登录用户的服务器。
spring.data.cassandra.username=username

#   自动创建视图和索引。
spring.data.couchbase.auto-index=false
#   默认情况下在生成的查询上应用的一致性。
spring.data.couchbase.consistency=read-your-own-writes 
#   启用Couchbase存储库
spring.data.couchbase.repositories.enabled=true

#   Elasticsearch集群名称。
spring.data.elasticsearch.cluster-name=elastic search
#   集群节点地址的逗号分隔列表。如果未指定，则启动客户端节点。
spring.data.elasticsearch.cluster-nodes=node
#   用于配置客户端的其他属性。
spring.data.elasticsearch.properties.xxx=xxx
#   启用Elasticsearch存储库
spring.data.elasticsearch.repositories.enabled=true

#   启用JPA存储库
spring.data.jpa.repositories.enabled=true
#   启用LDAP存储库。
spring.data.ldap.repositories.enabled=true

#   验证数据库名称
spring.data.mongodb.authentication-database=database
#   数据库名称
spring.data.mongodb.database=shop_db
#   要使用的FieldNamingStrategy的完全限定名称
spring.data.mongodb.field-naming-strategy=xxx
#   GridFS数据库名称
spring.data.mongodb.grid-fs-database=xxx
#   Mongo服务器主机。不能用uri设置。
spring.data.mongodb.host=localhost
#   数据库密码
spring.data.mongodb.password=password
#   服务器端口
spring.data.mongodb.port=27017
#   启用Mongo存储库。
spring.data.mongodb.repositories.enabled=true
#   mongodb：// localhost / test ＃Mongo数据库URI。无法设置主机，端口和凭据。
spring.data.mongodb.uri=uri
#   数据库用户名
spring.data.mongodb.username=username


#   编译器使用
spring.data.neo4j.compiler=debug
#   如果嵌入式驱动程序可用，启用嵌入式模式。
spring.data.neo4j.embedded.enabled=true
#   注册OpenSessionInViewInterceptor。绑定一个Neo4j会话到线程的整个处理请求。
spring.data.neo4j.open-in-view=true
#   登录服务器的密码
spring.data.neo4j.password=password
#   启用Neo4j存储库。
spring.data.neo4j.repositories.enabled=true
#   驱动程序使用的URI。默认情况下自动检测。
spring.data.neo4j.uri=uri
#   用户名
spring.data.neo4j.username=username



#   启用Redis存储库。
spring.data.redis.repositories.enabled=true


#   Spring Data REST使用的露出存储库资源的基本路径
spring.data.rest.base-path=base path
#   页面的默认大小
spring.data.rest.default-page-size=10
#   用于确定哪些存储库被暴露的策略。
spring.data.rest.detection-strategy=true
#   通过Spring Data REST默认资源包启用枚举值转换
spring.data.rest.enable-enum-translation=true
#   指示一次返回多少结果的URL查询字符串参数的名称
spring.data.rest.limit-param-name=name
#   最大页数
spring.data.rest.max-page-size=20
#   指示要返回的页面的URL查询字符串参数的名称。
spring.data.rest.page-param-name=p
#   创建一个实体后返回响应体。
spring.data.rest.return-body-on-create=true
#   更新实体后返回响应体。
spring.data.rest.return-body-on-update=true
#   指示排序结果的方向的URL查询字符串参数的名称。
spring.data.rest.sort-param-name=orderby



#   http：//127.0.0.1：8983 / solr ＃Solr主机。如果设置了“zk-host”，则被忽略。
spring.data.solr.host=localhost
#   启用Solr存储库。
spring.data.solr.repositories.enabled=true
#   ZooKeeper主机地址，格式为HOST：PORT。
spring.data.solr.zk-host=localhost


#   如果在初始化数据库时发生错误，请勿停止。
spring.datasource.continue-on-error=true
#   数据（DML）脚本资源引用。
spring.datasource.data=bootstrap.properties
#   执行DML脚本（如果不同）的数据库密码
spring.datasource.data-password=password
#   数据库用户执行DML脚本（如果不同）。
spring.datasource.data-username=username
#   JDBC驱动程序的完全限定名称。默认情况下，根据URL自动检测
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
#   生成随机数据源名称。
spring.datasource.generate-unique-name=false
#   使用'data.sql'填充数据库。
spring.datasource.initialize=true
#   启用JMX支持（如果由底层池提供）
spring.datasource.jmx-enabled=true
#   数据源的JNDI位置。设置时，类，网址，用户名和密码将被忽略
spring.datasource.jndi-name=name
#   数据源的名称
spring.datasource.name=testdb
#   数据源密码
spring.datasource.password=password
#   所有＃在DDL或DML脚本中使用的平台（例如模式 -  $ {platform} .sql或数据 -  $ {platform} .sql）。
spring.datasource.platform=all
#   Schema（DDL）脚本资源引用。
spring.datasource.schema=bootstrap.properties
#   执行DDL脚本的数据库密码（如果不同）。
spring.datasource.schema-password=password
#   数据库用户执行DDL脚本（如果不同）
spring.datasource.schema-username=username
#   语句分隔符在SQL初始化脚本中
spring.datasource.separator=;
#   SQL脚本编码。
spring.datasource.sql-script-encoding=utf-8
#
spring.datasource.tomcat.abandon-when-percentage-full=full
#
spring.datasource.tomcat.access-to-underlying-connection-allowed=true
spring.datasource.tomcat.alternate-username-allowed=true
spring.datasource.tomcat.commit-on-return=true
spring.datasource.tomcat.connection-properties=pro
spring.datasource.tomcat.data-source=source
spring.datasource.tomcat.data-source-j-n-d-i=xx
spring.datasource.tomcat.db-properties.xx=xxx
spring.datasource.tomcat.default-auto-commit=true
spring.datasource.tomcat.default-catalog=log
spring.datasource.tomcat.default-read-only=true
spring.datasource.tomcat.default-transaction-isolation=true
spring.datasource.tomcat.driver-class-name=class name
spring.datasource.tomcat.fair-queue=true
spring.datasource.tomcat.ignore-exception-on-pre-load=true
spring.datasource.tomcat.init-s-q-l=sql
spring.datasource.tomcat.initial-size=10
spring.datasource.tomcat.jdbc-interceptors=jdbc
spring.datasource.tomcat.jmx-enabled=true
spring.datasource.tomcat.log-abandoned=true
spring.datasource.tomcat.log-validation-errors=true
spring.datasource.tomcat.login-timeout=100000
spring.datasource.tomcat.max-active=100
spring.datasource.tomcat.max-age=100
spring.datasource.tomcat.max-idle=100
spring.datasource.tomcat.max-wait=100
spring.datasource.tomcat.min-evictable-idle-time-millis=1000000
spring.datasource.tomcat.min-idle=100
spring.datasource.tomcat.name=name
spring.datasource.tomcat.num-tests-per-eviction-run=run
spring.datasource.tomcat.password=password
spring.datasource.tomcat.propagate-interrupt-state=true
spring.datasource.tomcat.remove-abandoned=true
spring.datasource.tomcat.remove-abandoned-timeout=1000
spring.datasource.tomcat.rollback-on-return=true
spring.datasource.tomcat.suspect-timeout=10000
spring.datasource.tomcat.test-on-borrow=true
spring.datasource.tomcat.test-on-connect=true
spring.datasource.tomcat.test-on-return=true
spring.datasource.tomcat.test-while-idle=true
spring.datasource.tomcat.time-between-eviction-runs-millis=100000
spring.datasource.tomcat.url=url
spring.datasource.tomcat.use-disposable-connection-facade=true
spring.datasource.tomcat.use-equals=true
spring.datasource.tomcat.use-lock=true
spring.datasource.tomcat.use-statement-facade=true
spring.datasource.tomcat.username=username
spring.datasource.tomcat.validation-interval=100
spring.datasource.tomcat.validation-query=1
spring.datasource.tomcat.validation-query-timeout=10000
spring.datasource.tomcat.validator-class-name=class name


#   要使用的连接池实现的完全限定名称。默认情况下，它是从类路径自动检测的。
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
#   数据库的JDBC url。
spring.datasource.url=jdbc
#   登录数据库的用户。
spring.datasource.username=username
#   XA数据源完全限定名称。
spring.datasource.xa.data-source-class-name=org.springframework.boot.jta.bitronix.PoolingDataSourceBean.DirectXADataSource
#   传递给XA数据源的属性。
spring.datasource.xa.properties.xxx=xxx


#   连接超时（毫秒）。
spring.elasticsearch.jest.connection-timeout=3000
#   启用来自多个执行线程的连接请求。
spring.elasticsearch.jest.multi-threaded=true
#   登录密码
spring.elasticsearch.jest.password=password
#   HTTP客户端应该使用的代理主机。
spring.elasticsearch.jest.proxy.host=localhost
#   HTTP客户端应该使用的代理端口。
spring.elasticsearch.jest.proxy.port=10010
#   以毫秒读取超时。
spring.elasticsearch.jest.read-timeout=3000
#   http：// localhost：9200 ＃要使用的弹性搜索实例的逗号分隔列表。
spring.elasticsearch.jest.uris=localhost
#   登录用户
spring.elasticsearch.jest.username=username



#   设置是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名的模型属性。
spring.freemarker.allow-request-override=false
#   设置是否允许HttpSession属性重写（隐藏）控制器生成的同名的模型属性。
spring.freemarker.allow-session-override=false
#   启用模板缓存
spring.freemarker.cache=false
#   模板编码
spring.freemarker.charset=UTF-8
#   检查模板位置是否存在。
spring.freemarker.check-template-location=true
#   Content-Type值
spring.freemarker.content-type=text/html
#   启用此技术的MVC视图分辨率。
spring.freemarker.enabled=true
#   设置在与模板合并之前是否应将所有请求属性添加到模型中。
spring.freemarker.expose-request-attributes=false
#   设置在与模板合并之前是否应将所有HttpSession属性添加到模型中。
spring.freemarker.expose-session-attributes=false
#   设置是否公开一个RequestContext供Spring Spring宏的库使用，名称为“springMacroRequestContext”。
spring.freemarker.expose-spring-macro-helpers=true
#   首选文件系统访问模板加载。文件系统访问可以对模板更改进行热检测。
spring.freemarker.prefer-file-system-access=true
#   前缀，用于在构建URL时查看名称。
spring.freemarker.prefix=zr_
#   所有视图的
spring.freemarker.request-context-attribute=attr
#   众所周知的FreeMarker密钥将被传递给FreeMarker的配置。
spring.freemarker.settings.xx=xx
#   在构建URL时附加查看名称的后缀。
spring.freemarker.suffix=.ftl
#   classpath：/ templates /＃逗号分隔的模板路径列表。
spring.freemarker.template-loader-path=class path
#   可以解决的视图名称的白名单。
spring.freemarker.view-names=names



#   设置是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名的模型属性。
spring.groovy.template.allow-request-override=true
#   设置是否允许HttpSession属性重写（隐藏）控制器生成的同名的模型属性。
spring.groovy.template.allow-session-override=true
#   启用模板缓存。
spring.groovy.template.cache=false
#   模板编码
spring.groovy.template.charset=UTF-8
#   检查模板位置是否存在。
spring.groovy.template.check-template-location=false
#   请参阅GroovyMarkupConfigurer
spring.groovy.template.configuration.auto-escape=false
spring.groovy.template.configuration.auto-indent=false
spring.groovy.template.configuration.auto-indent-string=string
spring.groovy.template.configuration.auto-new-line=false
spring.groovy.template.configuration.base-template-class=class
spring.groovy.template.configuration.cache-templates=false
spring.groovy.template.configuration.declaration-encoding=utf-8
spring.groovy.template.configuration.expand-empty-elements=false
spring.groovy.template.configuration.locale=zh_CN
spring.groovy.template.configuration.new-line-string=string
spring.groovy.template.configuration.resource-loader-path=path
spring.groovy.template.configuration.use-double-quotes=false
#   Content-Type值
spring.groovy.template.content-type=text/html
#   启用此技术的MVC视图分辨率
spring.groovy.template.enabled=true
#   设置在与模板合并之前是否应将所有请求属性添加到模型中。
spring.groovy.template.expose-request-attributes=true
#   设置在与模板合并之前是否应将所有HttpSession属性添加到模型中。
spring.groovy.template.expose-session-attributes=true
#   设置在与模板合并之前是否应将所有HttpSession属性添加到模型中。
spring.groovy.template.expose-spring-macro-helpers=true
#   前缀，用于在构建URL时查看名称。
spring.groovy.template.prefix=zr_
#   所有视图的RequestContext属性的名称
spring.groovy.template.request-context-attribute=attr
#   classpath：/ templates / ＃模板路径。
spring.groovy.template.resource-loader-path=path
#   在构建URL时附加查看名称的后缀。
spring.groovy.template.suffix=.tpl
#   可以解决的视图名称的白名单
spring.groovy.template.view-names=names



#   启动控制台。
spring.h2.console.enabled=false
#   控制台可用的路径。
spring.h2.console.path=/h2-console
#   启用跟踪输出。
spring.h2.console.settings.trace=false
#   启用远程访问
spring.h2.console.settings.web-allow-others=false


#   指定应用程序/ hal + json响应是否应发送到接受application / json的请求。
spring.hateoas.use-hal-as-default-json-media-type=false
#   用于初始化Hazelcast的配置文件的位置。
spring.hazelcast.config=bootstrap.properties

#   用于HTTP消息转换的首选JSON映射器。设置为“gson”强制使用Gson，当它和Jackson都在类路径上时。
spring.http.converters.preferred-json-mapper=jackson
#   HTTP请求和响应的字符集。如果未明确设置，则添加到“Content-Type”头。
spring.http.encoding.charset=UTF-8
#   启用http编码支持。
spring.http.encoding.enabled=true
#   将编码强制到HTTP请求和响应上配置的字符集。
spring.http.encoding.force=false
#   将编码强制到HTTP请求上配置的字符集。“force”未指定时，默认为true。
spring.http.encoding.force-request=false
#   强制编码到HTTP响应上配置的字符集
spring.http.encoding.force-response=false
#   编码映射的区域设置。
spring.http.encoding.mapping.xxx=x-utf-32be-bom
#   启用对多部分上传的支持。
spring.http.multipart.enabled=true
#   将文件写入磁盘的阈值。值可以使用后缀“MB”或“KB”表示兆字节或千字节大小。
spring.http.multipart.file-size-threshold=0
#   上传文件的中间位置
spring.http.multipart.location=localhost
#   最大文件大小。值可以使用后缀“MB”或“KB”表示兆字节或千字节大小。
spring.http.multipart.max-file-size=1MB
#   最大请求大小。值可以使用后缀“MB”或“KB”表示兆字节或千字节大小。
spring.http.multipart.max-request-size=10MB
#   是否在文件或参数访问时懒惰地解析多部分请求
spring.http.multipart.resolve-lazily=false


#   classpath：META-INF / build-info.properties，生成的build-info.properties文件的位置。
spring.info.build.location=bootstrap.properties
#   类路径：git.properties 生成的git.properties文件＃所在。
spring.info.git.location=bootstrap.properties



#   日期格式字符串或全限定日期格式类名。例如`yyyy-MM-dd HH：mm：ss`。
spring.jackson.date-format=java.text.SimpleDateFormat
#   控制序列化期间属性的包含。
spring.jackson.default-property-inclusion=always
#   影响Java对象反序列化方式的杰克逊开/关功能。
spring.jackson.deserialization.accept-empty-array-as-null-object=xxx
#   发生器的杰克逊开/关功能。
spring.jackson.generator.auto-close-json-content=xxx
#   Joda日期时间格式字符串。如果未配置，如果配置了格式字符串，则“日期格式”将用作后备。
spring.jackson.joda-date-time-format=Y-M-D HH:ii:ss
#   用于格式化的区域设置。
spring.jackson.locale=zh_CN
#   Jackson通用开/关功能。
spring.jackson.mapper.accept-case-insensitive-properties=xxx
#   解析器的杰克逊开/关功能。
spring.jackson.parser.allow-backslash-escaping-any-character=xxx
#   Jackson的PropertyNamingStrategy的一个常量。也可以是PropertyNamingStrategy子类的完全限定类名。
spring.jackson.property-naming-strategy=stratefy
#   影响Java对象序列化方式的杰克逊开/关功能。
spring.jackson.serialization.close-closeable=close
#   格式化日期时使用的时区。例如`America / Los_Angeles`
spring.jackson.time-zone=PRC


#   作为应用程序的基本URI的路径。如果指定，则覆盖“@ApplicationPath”的值。
spring.jersey.application-path=app path
#   泽西过滤器链序。
spring.jersey.filter.order=0
#   Init参数通过servlet或过滤器传递给泽西
spring.jersey.init.xxx=xxx
#   加载Jersey servlet的启动优先级。
spring.jersey.servlet.load-on-startup=1
#   泽西集成类型。
spring.jersey.type=servlet




#   连接工厂JNDI名称。设置时，优先于其他连接工厂自动配置。
spring.jms.jndi-name=name
#   容器的确认模式。默认情况下，监听器被自动确认处理
spring.jms.listener.acknowledge-mode=auto
#   启动时自动启动容器。
spring.jms.listener.auto-startup=true
#   最小并发消费者数
spring.jms.listener.concurrency=con
#   最大并发消费者数。
spring.jms.listener.max-concurrency=xxx
#   指定默认的目的地类型是否为主题。
spring.jms.pub-sub-domain=false
#   在没有目标参数的发送/接收操作上使用的默认目标
spring.jms.template.default-destination=dest
#   于发送呼叫的传送延迟（以毫秒为单位）。
spring.jms.template.delivery-delay=1000
#   传递模式。设置时启用QoS
spring.jms.template.delivery-mode=non_persistent
#   发送时的消息优先级。设置时启用QoS。
spring.jms.template.priority=pri
#   发送消息时启用显式QoS。
spring.jms.template.qos-enabled=false
#   用于以毫秒为单位的接收呼叫的超时。
spring.jms.template.receive-timeout=10000
#   以毫秒为单位发送时的消息生存时间。设置时启用QoS
spring.jms.template.time-to-live=live




#   MX域名。
spring.jmx.default-domain=xxx.com
#   将管理bean暴露给JMX域。
spring.jmx.enabled=true
#   MBeanServer bean名称。
spring.jmx.server=mbeanServer




#   与配置的数据源通信时使用的SQLDialect JOOQ。例如`POSTGRES`
spring.jooq.sql-dialect=xxx


#   目标数据库进行操作，默认情况下自动检测。可以使用“databasePlatform”属性设置。
spring.jpa.database=db
#   要运行的目标数据库的名称，默认情况下自动检测。可以使用“数据库”枚举来设置。
spring.jpa.database-platform=mysql
#   启动时初始化模式。
spring.jpa.generate-ddl=false
#   DDL模式。这实际上是“hibernate.hbm2ddl.auto”属性的快捷方式。使用嵌入式数据库时默认为“创建删除”，否则为“否”。
spring.jpa.hibernate.ddl-auto=create
#   Hibernate 5隐式命名策略完全限定名。
spring.jpa.hibernate.naming.implicit-strategy=xxx
#   Hibernate 5物理命名策略完全限定名。
spring.jpa.hibernate.naming.physical-strategy=xxx
#   Hibernate 4命名策略完全限定名。Hibernate不支持5
spring.jpa.hibernate.naming.strategy=xxx
#   对于AUTO，TABLE和SEQUENCE，使用Hibernate的较新的IdentifierGenerator。
spring.jpa.hibernate.use-new-id-generator-mappings=false
#   注册OpenEntityManagerInViewInterceptor。将JPA EntityManager绑定到线程以进行请求的整个处理。
spring.jpa.open-in-view=true
#   在JPA提供程序上设置的其他本机属性。
spring.jpa.properties.xxx=xxx
#   启用SQL语句的日志记录。
spring.jpa.show-sql=true
#   从池中借出连接的超时（秒）。
spring.jta.atomikos.connectionfactory.borrow-connection-timeout=30
#   创建会话时是否忽略事务标志。
spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag=true
#   是否需要本地事务。
spring.jta.atomikos.connectionfactory.local-transaction-mode=true
#   池的维护线程运行之间的时间（以秒为单位）。
spring.jta.atomikos.connectionfactory.maintenance-interval=1000
#   从池中清除连接的时间（以秒为单位）。
spring.jta.atomikos.connectionfactory.max-idle-time=1000
#   在被破坏之前可以将连接合并的时间（以秒为单位）。0表示无限制。
spring.jta.atomikos.connectionfactory.max-lifetime=1000
#   池的最大大小
spring.jta.atomikos.connectionfactory.max-pool-size=10
#   池的最小大小
spring.jta.atomikos.connectionfactory.min-pool-size=10
#   借用连接的收获超时（以秒为单位）。0表示无限制。
spring.jta.atomikos.connectionfactory.reap-timeout=1000
#   在恢复期间用于标识资源的唯一名称。
spring.jta.atomikos.connectionfactory.unique-resource-name=jmsConnectionFactory
#   从池中借出连接的超时（秒）。
spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name=name
#
spring.jta.atomikos.connectionfactory.xa-properties.xxx=xxx
#   从池中借出连接的超时（秒）。
spring.jta.atomikos.datasource.borrow-connection-timeout=1000
#   池提供的连接的默认隔离级别。
spring.jta.atomikos.datasource.default-isolation-level=debug
#   用于建立数据库连接的超时（以秒为单位）。
spring.jta.atomikos.datasource.login-timeout=1000
#   池的维护线程运行之间的时间（以秒为单位）。
spring.jta.atomikos.datasource.maintenance-interval=1000
#   从池中清除连接的时间（以秒为单位）。
spring.jta.atomikos.datasource.max-idle-time=1000
#   在被破坏之前可以将连接合并的时间（以秒为单位）。0表示无限制。
spring.jta.atomikos.datasource.max-lifetime=1000
#   池的最大大小。
spring.jta.atomikos.datasource.max-pool-size=10
#   池的最小大小。
spring.jta.atomikos.datasource.min-pool-size=10
#   借用连接的收获超时（以秒为单位）。0表示无限制。
spring.jta.atomikos.datasource.reap-timeout=1000
#   用于在返回连接之前验证连接的SQL查询或语句。
spring.jta.atomikos.datasource.test-query=1
#   用于在恢复期间识别资源的唯一名称。
spring.jta.atomikos.datasource.unique-resource-name=dataSource
#
spring.jta.atomikos.datasource.xa-data-source-class-name=name
#
spring.jta.atomikos.datasource.xa-properties.xxx=xxx
#   检查点之间的间隔。
spring.jta.atomikos.properties.checkpoint-interval=500
#
spring.jta.atomikos.properties.console-log-level=warn
#   JTA事务的默认超时。
spring.jta.atomikos.properties.default-jta-timeout=10000
#   启用磁盘日志记录。
spring.jta.atomikos.properties.enable-logging=true
#   指定VM关闭是否应触发事务核心强制关闭。
spring.jta.atomikos.properties.force-shutdown-on-vm-exit=true
#   应该存储日志文件的目录。
spring.jta.atomikos.properties.log-base-dir=dir
#   事务日志文件的基础名称。
spring.jta.atomikos.properties.log-base-name=tmlog
#   最大活动事务数。
spring.jta.atomikos.properties.max-actives=50
#   事务允许的最大超时（以毫秒为单位）。
spring.jta.atomikos.properties.max-timeout=3000000
#   指定如果可能的话，应该加入子事务
spring.jta.atomikos.properties.serial-jta-transactions=true
#   应该启动的事务管理器实现。
spring.jta.atomikos.properties.service=service
#   对参与资源使用不同（和并发）线程进行两阶段提交。
spring.jta.atomikos.properties.threaded-two-phase-commit=true
#   事务管理器的唯一名称。
spring.jta.atomikos.properties.transaction-manager-unique-name=name
#   增长池时要创建的连接数。
spring.jta.bitronix.connectionfactory.acquire-increment=100
#   在获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。
spring.jta.bitronix.connectionfactory.acquisition-interval=1000
#   从池中获取连接的超时（以秒为单位）。
spring.jta.bitronix.connectionfactory.acquisition-timeout=100
#   事务管理器是否允许混合XA和非XA事务。
spring.jta.bitronix.connectionfactory.allow-local-transactions=true
#   事件超时是否应该在XAResource被登记时设置。
spring.jta.bitronix.connectionfactory.apply-transaction-timeout=true
#   资源是否应该被自动登记和删除。
spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled=true
#   是否生产和消费者应该被缓存。
spring.jta.bitronix.connectionfactory.cache-producers-consumers=true
#
spring.jta.bitronix.connectionfactory.class-name=name

#   提供程序是否可以在同一连接上运行许多事务，并支持事务交织。
spring.jta.bitronix.connectionfactory.defer-connection-release=true
#
spring.jta.bitronix.connectionfactory.disabled=true
#
spring.jta.bitronix.connectionfactory.driver-properties.xxx=xxx
#
spring.jta.bitronix.connectionfactory.failed=true
#   是否应忽略恢复失败。
spring.jta.bitronix.connectionfactory.ignore-recovery-failures=true
#   从池中清除连接之后的时间（以秒为单位）
spring.jta.bitronix.connectionfactory.max-idle-time=100
#   池的最大大小。0表示无限制。
spring.jta.bitronix.connectionfactory.max-pool-size=10
#   池的最小大小。
spring.jta.bitronix.connectionfactory.min-pool-size=10
#   用于连接到JMS提供程序的密码。
spring.jta.bitronix.connectionfactory.password=password
#   ACCESSIBLE状态中的连接是否可以在事务的上下文中共享。
spring.jta.bitronix.connectionfactory.share-transaction-connections=true
#   从池中获取连接是否应该进行测试。
spring.jta.bitronix.connectionfactory.test-connections=true
#   在两阶段提交期间该资源应该采取的位置（始终为Integer.MIN_VALUE，始终为Integer.MAX_VALUE）。
spring.jta.bitronix.connectionfactory.two-pc-ordering-position=position
spring.jta.bitronix.connectionfactory.unique-name=jmsConnectionFactory
#   启动XAResource时是否应使用TMJOIN。
spring.jta.bitronix.connectionfactory.use-tm-join=true
#   用于连接到JMS提供者的用户
spring.jta.bitronix.connectionfactory.user=user
#   生成池时要创建的连接数
spring.jta.bitronix.datasource.acquire-increment=1
#   在获取无效连接后再尝试获取连接之前等待的时间（以秒为单位）。
spring.jta.bitronix.datasource.acquisition-interval=1000
#   从池中获取连接的超时（以秒为单位）。
spring.jta.bitronix.datasource.acquisition-timeout=1000
#   事务管理器是否允许混合XA和非XA事务
spring.jta.bitronix.datasource.allow-local-transactions=true
#   事件超时是否应该在XAResource被登记时设置。
spring.jta.bitronix.datasource.apply-transaction-timeout=true
#   资源是否应该被登记和自动删除。
spring.jta.bitronix.datasource.automatic-enlisting-enabled=true
#
spring.jta.bitronix.datasource.class-name=name
#   连接的默认游标保持性
spring.jta.bitronix.datasource.cursor-holdability=h
#   数据库是否可以在同一连接上运行许多事务，并支持事务交织。
spring.jta.bitronix.datasource.defer-connection-release=true
#
spring.jta.bitronix.datasource.disabled=true
#
spring.jta.bitronix.datasource.driver-properties.xxx=xxx
#   从池中获取连接时是否调用Connection.isValid（）
spring.jta.bitronix.datasource.enable-jdbc4-connection-test=true
#
spring.jta.bitronix.datasource.failed=true
#   是否应忽略恢复失败。
spring.jta.bitronix.datasource.ignore-recovery-failures=true
#   连接的默认隔离级别
spring.jta.bitronix.datasource.isolation-level=debug
#   地事务的默认自动提交模式
spring.jta.bitronix.datasource.local-auto-commit=true
#   用于建立数据库连接的超时（以秒为单位）。
spring.jta.bitronix.datasource.login-timeout=1000
#   从池中清除连接之后的时间（以秒为单位）
spring.jta.bitronix.datasource.max-idle-time=100
#   池的最大大小。0表示无限制。
spring.jta.bitronix.datasource.max-pool-size=10
#   池的最小大小
spring.jta.bitronix.datasource.min-pool-size=10
#   准备好的语句高速缓存的目标大小。0禁用缓存
spring.jta.bitronix.datasource.prepared-statement-cache-size=10
#   ACCESSIBLE状态下的连接是否可以在事务的上下文中共享。
spring.jta.bitronix.datasource.share-transaction-connections=true
#   用于在返回连接之前验证连接的SQL查询或语句
spring.jta.bitronix.datasource.test-query=1
#   这个资源在两阶段提交期间应该采取的位置（始终是Integer.MIN_VALUE，始终是Integer.MAX_VALUE）。
spring.jta.bitronix.datasource.two-pc-ordering-position=1
#   用于在恢复期间标识资源的唯一名称
spring.jta.bitronix.datasource.unique-name=dataSource
#   启动XAResource时是否应使用TMJOIN
spring.jta.bitronix.datasource.use-tm-join=true
#   启用JTA支持
spring.jta.enabled=true
#   Transaction logs目录。
spring.jta.log-dir=dir
#   事务超时（以秒为单位）
spring.jta.narayana.default-timeout=60
#   逗号分隔的过期扫描器列表
spring.jta.narayana.expiry-scanners=com.arjuna.ats.internal.arjuna.recovery.ExpiredTransactionStatusManagerScanner
#   事务对象存储目录
spring.jta.narayana.log-dir=dir
#   启用一个阶段提交优化
spring.jta.narayana.one-phase-commit=true
#   在几秒内执行定期恢复扫描的间隔
spring.jta.narayana.periodic-recovery-period=120
#   恢复扫描的第一和第二阶段之间的时间间隔（秒）。
spring.jta.narayana.recovery-backoff-period=10
#   恢复管理器使用的数据库密码
spring.jta.narayana.recovery-db-pass=pass
#   恢复管理器使用的数据库用户名
spring.jta.narayana.recovery-db-user=user
#   恢复管理器使用的JMS密码
spring.jta.narayana.recovery-jms-pass=pass
#   恢复管理器使用的JMS用户名
spring.jta.narayana.recovery-jms-user=user
#   恢复模块的逗号分隔列表
spring.jta.narayana.recovery-modules=module
#   唯一事务管理器ID
spring.jta.narayana.transaction-manager-id=1
#   孤立筛选器的逗号分隔列表
spring.jta.narayana.xa-resource-orphan-filters=filters
#   事务管理器唯一标识符
spring.jta.transaction-manager-id=id




#   用于建立与Kafka集群的初始连接的主机：端口对的逗号分隔列表
spring.kafka.bootstrap-servers=servers
#   在发出请求时传递给服务器的Id; 用于服务器端日志记录
spring.kafka.client-id=cliet
#   如果“enable.auto.commit”为真，则以毫秒为单位的消费者偏移量自动提交给Kafka的频率。
spring.kafka.consumer.auto-commit-interval=1000
#   当Kafka中没有初始偏移量时，如果服务器上当前的偏移量不再存在，该怎么办？
spring.kafka.consumer.auto-offset-reset=earliest
#   用于建立与Kafka集群的初始连接的主机：端口对的逗号分隔列表。
spring.kafka.consumer.bootstrap-servers=servers
#   Id在发出请求时传递给服务器; 用于服务器端日志记录。
spring.kafka.consumer.client-id=client
#   如果为true，消费者的偏移将在后台定期提交
spring.kafka.consumer.enable-auto-commit=true
#   如果没有足够的数据来满足“fetch.min.bytes”的要求，服务器将在接收到提取请求之前阻止的最大时间（以毫秒为单位）。
spring.kafka.consumer.fetch-max-wait=100
#   服务器应以字节为单位返回一个提取请求的最小数据量
spring.kafka.consumer.fetch-min-size=10
#   用于标识此消费者所属消费群组的唯一字符串
spring.kafka.consumer.group-id=1
#   心跳线与消费者协调器之间的预期时间（毫秒）
spring.kafka.consumer.heartbeat-interval=1000
#   解串器类的键
spring.kafka.consumer.key-deserializer=antlr
#   在一次调用poll（）中返回的最大记录数
spring.kafka.consumer.max-poll-records=logs
#   解串器类的值
spring.kafka.consumer.value-deserializer=antlr
#   当ackMode为“COUNT”或“COUNT_TIME”时，偏移提交之间的记录数。
spring.kafka.listener.ack-count=100
#   Listener AckMode; 参见spring-kafka文件。
spring.kafka.listener.ack-mode=100
#   当ackMode为“TIME”或“COUNT_TIME”时，偏移提交之间的时间（以毫秒为单位）。
spring.kafka.listener.ack-time=100
#   在侦听器容器中运行的线程数。
spring.kafka.listener.concurrency=10
#   轮询消费者时使用的超时时间（以毫秒为单位）
spring.kafka.listener.poll-timeout=1000
#   生产者要求领导在考虑请求完成之前收到的确认数。
spring.kafka.producer.acks=100
#   发送前要批量的记录数。
spring.kafka.producer.batch-size=10
#   用于建立与Kafka集群的初始连接的主机：端口对的逗号分隔列表。
spring.kafka.producer.bootstrap-servers=servers
#   生产者可以用来缓冲等待发送到服务器的记录的总字节数。
spring.kafka.producer.buffer-memory=100
#   Id在发出请求时传递给服务器; 用于服务器端日志记录。
spring.kafka.producer.client-id=client
#   由生产者生成的所有数据的压缩类型。
spring.kafka.producer.compression-type=type
#   键序列化器类。
spring.kafka.producer.key-serializer=antlr
#   当大于零时，可以重试失败的发送。
spring.kafka.producer.retries=ret
#   用于值的串行化器类
spring.kafka.producer.value-serializer=antlr
#   用于配置客户端的附加属性。
spring.kafka.properties.xxx=xxx
#   密钥存储文件中私钥的密码。
spring.kafka.ssl.key-password=password
#   密钥存储文件的位置
spring.kafka.ssl.keystore-location=bootstrap.properties
#   存储密钥存储文件的密码
spring.kafka.ssl.keystore-password=password
#   信任存储文件的位置。
spring.kafka.ssl.truststore-location=bootstrap.properties
#   存储信任存储文件的密码。
spring.kafka.ssl.truststore-password=password
#   将发送消息的默认主题
spring.kafka.template.default-topic=10




#   所有操作应该源于的基本后缀
spring.ldap.base=base
#   LDAP规范设置。
spring.ldap.base-environment.xxx=xxx
#   基本DN
spring.ldap.embedded.base-dn=dn
#   嵌入式LDAP密码。
spring.ldap.embedded.credential.password=password
#   嵌入式LDAP用户名。
spring.ldap.embedded.credential.username=username
#   Schema（LDIF）脚本资源引用
spring.ldap.embedded.ldif=classpath：schema.ldif
#   嵌入式LDAP端口。
spring.ldap.embedded.port=0
#   启用LDAP模式验证。
spring.ldap.embedded.validation.enabled=true
#   自定义模式的路径
spring.ldap.embedded.validation.schema=bootstrap.properties
#   登录服务器的密码
spring.ldap.password=password
#   服务器的LDAP URL
spring.ldap.urls=urls
#   登录用户的服务器
spring.ldap.username=username




#   默认MimeMessage编码。
spring.mail.default-encoding=UTF-8
#   SMTP服务器主机。例如`smtp.example.com`
spring.mail.host=localhost
#   Session JNDI name。设置时，优先于其他邮件设置。
spring.mail.jndi-name=name
#   登录SMTP服务器的密码。
spring.mail.password=password
#   SMTP服务器端口
spring.mail.port=443
#   他JavaMail会话属性。
spring.mail.properties.xxx=xxx
#   SMTP服务器使用的协议。
spring.mail.protocol=smtp
#   测试邮件服务器在启动时可用。
spring.mail.test-connection=false
#   登录SMTP服务器的用户。
spring.mail.username=username



#   应用程序运行时用于显示横幅的模式。
spring.main.banner-mode=console
#   要包含在ApplicationContext中的源（类名，包名或XML资源位置）
spring.main.sources=sources
#   在Web环境中运行应用程序（默认情况下自动检测）。
spring.main.web-environment=false



#   应用程序必须使用的预期字符编码。
spring.mandatory-file-encoding=UTF-8



#   设置是否始终应用MessageFormat规则，解析没有参数的偶数消息。
spring.messages.always-use-message-format=false
#   基于逗号分隔的基础名称列表，每个都在ResourceBundle约定之后
spring.messages.basename=messages
#   加载的资源束文件缓存到期，以秒为单位。设置为-1时，软件包将永久缓存
spring.messages.cache-seconds=-1
#   消息束编码
spring.messages.encoding=UTF-8
#   设置是否返回到系统区域设置，如果没有找到特定语言环境的文件。
spring.messages.fallback-to-system-locale=true


#   告诉聚合器使用源存储库中的键做什么的模式。
spring.metrics.export.aggregate.key-pattern=patt
#   全局存储库的前缀如果处于活动状态。
spring.metrics.export.aggregate.prefix=zr_
#   导出刻度之间以毫秒为单位的延迟。按照这种延迟，指标将按计划导出到外部来源。
spring.metrics.export.delay-millis=1000000
#   启用度量标准导出的标志（假设MetricWriter可用）。
spring.metrics.export.enabled=true
#   要排除的度量名称的模式列表。应用后包括。
spring.metrics.export.excludes=xx
#   要包括的度量名称的模式列表。
spring.metrics.export.includes=xxx
#   redis存储库导出的密钥（如果处于活动状态）。
spring.metrics.export.redis.key=keys.spring.metrics
#   redis存储库的前缀如果处于活动状态。
spring.metrics.export.redis.prefix=spring.metrics
#   根据不导出不变的度量值关闭所有可用的优化。
spring.metrics.export.send-latest=true
#   用于接收导出指标的statsd服务器的主机。
spring.metrics.export.statsd.host=localhost
#   接收导出指标的statsd服务器端口
spring.metrics.export.statsd.port=8125
#   statsd导出指标的前缀。
spring.metrics.export.statsd.prefix=zr_
#   每个MetricWriter bean名称的特定触发器属性。
spring.metrics.export.triggers.xxx=xxx





#   启用对后退解析的支持。
spring.mobile.devicedelegatingviewresolver.enable-fallback=true
#   启用设备视图解析器
spring.mobile.devicedelegatingviewresolver.enabled=true
#   前缀，用于查看移动设备的名称。
spring.mobile.devicedelegatingviewresolver.mobile-prefix= mobile/
#   后缀，附加到查看移动设备的名称。
spring.mobile.devicedelegatingviewresolver.mobile-suffix=zr_
#   前缀，用于查看普通设备的名称。
spring.mobile.devicedelegatingviewresolver.normal-prefix=zr_
#   后缀被追加到查看普通设备的名称
spring.mobile.devicedelegatingviewresolver.normal-suffix=_rz
#   前缀，用于查看平板设备的名称
spring.mobile.devicedelegatingviewresolver.tablet-prefix=tablet/
#   后缀，附加到查看平板设备的名称。
spring.mobile.devicedelegatingviewresolver.tablet-suffix=_rz
#   启用SitePreferenceHandler。
spring.mobile.sitepreference.enabled=true



#   启用功能的逗号分隔列表。
spring.mongodb.embedded.features=SYNC_DELAY
#   用于数据存储的目录。
spring.mongodb.embedded.storage.database-dir=dir
#   oplog的最大大小（兆字节）。
spring.mongodb.embedded.storage.oplog-size=10
#   副本集的名称。
spring.mongodb.embedded.storage.repl-set-name=name
#   Mongo使用版本。
spring.mongodb.embedded.version=3.2.2




#   设置是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名的模型属性。
spring.mustache.allow-request-override=false
#   设置是否允许HttpSession属性重写（隐藏）控制器生成的同名的模型属性
spring.mustache.allow-session-override=false
#   启用模板缓存。
spring.mustache.cache=false
#   模板编码。
spring.mustache.charset=UTF-8
#   检查模板位置是否存在。
spring.mustache.check-template-location=true
#   Content-Type值。
spring.mustache.content-type=text/html
#   启用此技术的MVC视图分辨率。
spring.mustache.enabled=true
#   设置在与模板合并之前是否应将所有请求属性添加到模型中。
spring.mustache.expose-request-attributes=false
#   设置在与模板合并之前是否应将所有HttpSession属性添加到模型中。
spring.mustache.expose-session-attributes=false
#   设置是否公开一个RequestContext供Spring Spring的宏库使用，名称为“springMacroRequestContext”。
spring.mustache.expose-spring-macro-helpers=true
#   应用于模板名称的前缀。
spring.mustache.prefix=classpath:/templates/
#   所有视图的
spring.mustache.request-context-attribute=attr
#   应用于模板名称的后缀。
spring.mustache.suffix=.html
#   可以解决的视图名称的白名单。
spring.mustache.view-names=names





#   异步请求处理超时之前的时间量（以毫秒为单位）
spring.mvc.async.request-timeout=100000
#   要使用的日期格式。例如`dd / MM / yyyy`。
spring.mvc.date-format=ymd
#   向FrameworkServlet doService方法发送OPTIONS请求。
spring.mvc.dispatch-options-request=true
#   向FrameworkServlet doService方法发送TRACE请求。
spring.mvc.dispatch-trace-request=false
#   启用favicon.ico的解析。
spring.mvc.favicon.enabled=true
#   启用Spring的HttpPutFormContentFilter。
spring.mvc.formcontent.putfilter.enabled=true
#   如果在重定向方案期间应该忽略“默认”模型的内容。
spring.mvc.ignore-default-model-on-redirect=true
#   使用的区域设置。默认情况下，该语言环境被“Accept-Language”标头覆盖。
spring.mvc.locale=zh_CN
#   定义应该如何解决区域设置。
spring.mvc.locale-resolver=accept_header
#   启用由“HandlerExceptionResolver”解析的异常的警告日志记录
spring.mvc.log-resolved-exception=false
#   将文件扩展名映射到内容协商的媒体类型。
spring.mvc.media-types.xxx=application/prs.xsf+xml
#   消息代码格式策略。例如`PREFIX_ERROR_CODE`。
spring.mvc.message-codes-resolver-format=postfix_error_code
#   加载Spring Web Services servlet的启动优先级
spring.mvc.servlet.load-on-startup=-1
#   用于静态资源的路径模式。
spring.mvc.static-path-pattern=/**
#   如果没有发现处理程序处理请求，则应抛出“NoHandlerFoundException”。
spring.mvc.throw-exception-if-no-handler-found=false
#   Spring MVC视图前缀。
spring.mvc.view.prefix=mvc
#   Spring MVC视图后缀。
spring.mvc.view.suffix=mvc



#   检测＃配置ANSI输出。
spring.output.ansi.enabled=detect

#   如果使用ApplicationPidFileWriter但是无法写入PID文件，则失败。
spring.pid.fail-on-write-error=false
#   要写入的PID文件的位置（如果使用ApplicationPidFileWriter）
spring.pid.file=file



#   （如果使用YAML或列表）的逗号分隔列表活性谱。
spring.profiles.active=test
#   无条件地激活指定的逗号分隔的配置文件（或使用YAML的配置文件列表）
spring.profiles.include=xxx






#   客户端应连接到的逗号分隔的地址列表。
spring.rabbitmq.addresses=add
#   如果达到缓存大小，等待获取通道的毫秒数
spring.rabbitmq.cache.channel.checkout-timeout=10000
#   缓存中保留的通道数。
spring.rabbitmq.cache.channel.size=10
#   连接工厂缓存模式。
spring.rabbitmq.cache.connection.mode=channel
#   要缓存的连接数。
spring.rabbitmq.cache.connection.size=10
#   连接超时，以毫秒为单位; 零为无限。
spring.rabbitmq.connection-timeout=1000
#   创建AmqpAdmin豆。
spring.rabbitmq.dynamic=true
#   RabbitMQ主机。
spring.rabbitmq.host=localhost
#   容器的确认模式。
spring.rabbitmq.listener.simple.acknowledge-mode=mode
#   启动时自动启动容器。
spring.rabbitmq.listener.simple.auto-startup=true
#   最少消费者数量。
spring.rabbitmq.listener.simple.concurrency=con
#   是否重新发送传递失败; 默认为“true”。
spring.rabbitmq.listener.simple.default-requeue-rejected=true
#   空闲容器事件应以毫秒为单位发布的频率
spring.rabbitmq.listener.simple.idle-event-interval=10000
#   最大消费者数。
spring.rabbitmq.listener.simple.max-concurrency=con
#   在单个请求中处理的消息数。它应该大于或等于事务大小（如果使用）。
spring.rabbitmq.listener.simple.prefetch=pre
#   是否启用发布重试。
spring.rabbitmq.listener.simple.retry.enabled=false
#   第一次和第二次传递消息之间的间隔
spring.rabbitmq.listener.simple.retry.initial-interval=10000
#   传递消息的最大尝试次数。
spring.rabbitmq.listener.simple.retry.max-attempts=3
#   尝试之间的最大间隔。
spring.rabbitmq.listener.simple.retry.max-interval=10000
#   应用于之前的传递重试间隔的乘数。
spring.rabbitmq.listener.simple.retry.multiplier=1
#   重试是否无状态或有状态
spring.rabbitmq.listener.simple.retry.stateless=true
#   在事务中要处理的消息数。为了获得最佳结果，它应该小于或等于预取计数。
spring.rabbitmq.listener.simple.transaction-size=10
#   登录以对代理进行身份验证。
spring.rabbitmq.password=password
#   RabbitMQ端口。
spring.rabbitmq.port=5672
#   启用发布商确认。
spring.rabbitmq.publisher-confirms=false
#   启用发布者返回。
spring.rabbitmq.publisher-returns=false
#   请求的心跳超时，以秒为单位; 零为无。
spring.rabbitmq.requested-heartbeat=xxx
#   使用SSL算法。默认情况下由兔子客户端配置
spring.rabbitmq.ssl.algorithm=ssl
#   启用SSL支持。
spring.rabbitmq.ssl.enabled=false
#   保存SSL证书的密钥存储区的路径。
spring.rabbitmq.ssl.key-store=path
#   用于访问密钥库的密码。
spring.rabbitmq.ssl.key-store-password=password
#   保存SSL证书的Trust存储。
spring.rabbitmq.ssl.trust-store=redis
#   用于访问信任存储的密码。
spring.rabbitmq.ssl.trust-store-password=password
#   启用强制性消息。
spring.rabbitmq.template.mandatory=false
#   receive（）`方法的超时。
spring.rabbitmq.template.receive-timeout=1000
#   “sendAndReceive（）”方法的超时。
spring.rabbitmq.template.reply-timeout=1000
#   设置为true以在“RabbitTemplate”中启用重试。
spring.rabbitmq.template.retry.enabled=false
#   1000＃发布消息的第一次和第二次尝试之间的间隔。
spring.rabbitmq.template.retry.initial-interval=1000
#   发送消息的最大尝试次数。
spring.rabbitmq.template.retry.max-attempts=3
#   发送邮件的最大尝试次数。
spring.rabbitmq.template.retry.max-interval=10000
#   应用于以前的发布重试间隔的乘数。
spring.rabbitmq.template.retry.multiplier=1
#   登录用户对代理进行身份验证。
spring.rabbitmq.username=username
#   连接到代理时使用的虚拟主机。
spring.rabbitmq.virtual-host=localhost




#   在集群中执行命令时要执行的最大重定向次数
spring.redis.cluster.max-redirects=100
#   集群节点
spring.redis.cluster.nodes=nodes
#   连接所述库
spring.redis.database=0
#   redis host
spring.redis.host=localhost
#   redis password
spring.redis.password=password
#   在给定时间池可以分配的最大连接数。使用负值为无限制。
spring.redis.pool.max-active=8
#   池中“空闲”连接的最大数量。使用负值来表示无限数量的空闲连接。
spring.redis.pool.max-idle=8
#   连接分配在池耗尽时引发异常之前应阻止的最大时间（以毫秒为单位）。使用负值无限期地阻止。
spring.redis.pool.max-wait=-1
#   定义池中维护的最小空闲连接数。此设置只有在正值时才有效果。
spring.redis.pool.min-idle=0
#   redis 端口号
spring.redis.port=6379
#   哨兵mater名称
spring.redis.sentinel.master=master
#   哨兵节点
spring.redis.sentinel.nodes=nodes
#   是否使用ssl
spring.redis.ssl=false
#   连接超时（以毫秒为单位）。
spring.redis.timeout=0
#   连接URL，将覆盖主机，端口和密码（用户将被忽略），例如redis：// user：password@example.com ：6379
spring.redis.url=url




#   启用默认资源处理。
spring.resources.add-mappings=true
#   由资源处理程序提供的资源的缓存期，以秒为单位。
spring.resources.cache-period=10
#   在资源链中启用缓存。
spring.resources.chain.cache=true
#   启用Spring资源处理链。默认情况下禁用，除非启用了至少一个策略。
spring.resources.chain.enabled=true
#   启用已经gzip压缩资源的解析。
spring.resources.chain.gzipped=true
#   启用HTML5应用程序缓存清单重写。
spring.resources.chain.html-application-cache=false
#   启用内容版本策略。
spring.resources.chain.strategy.content.enabled=false
#   应用于版本策略的模式的逗号分隔列表。
spring.resources.chain.strategy.content.paths=/**
#   启用固定版本策略。
spring.resources.chain.strategy.fixed.enabled=false
#   应用于版本策略的逗号分隔的模式列表。
spring.resources.chain.strategy.fixed.paths=/**
#   用于版本策略的版本字符串。
spring.resources.chain.strategy.fixed.version=1.0.0
#   静态资源的位置。
spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/




#   SendGrid api密钥（用户名/密码替代）。
spring.sendgrid.api-key=api-key
#   SendGrid帐户密码。
spring.sendgrid.password=password
#   SendGrid代理主机。
spring.sendgrid.proxy.host=localhost
#   SendGrid代理端口。
spring.sendgrid.proxy.port=600
#   SendGrid帐户用户名。
spring.sendgrid.username=username



#   Sessions flush模式。
spring.session.hazelcast.flush-mode=on-save
#   用于存储会话的地图名称
spring.session.hazelcast.map-name=spring:session:sessions
#   如果需要，在启动时创建所需的会话表。如果设置了默认表名或配置了自定义模式，则自动启用。
spring.session.jdbc.initializer.enabled=false
#   用于初始化数据库模式的SQL文件的路径。
spring.session.jdbc.schema=classpath:/org / springframework / session / jdbc / schema- @ @ platform @ @ .sql
#   用于存储会话的数据库表的名称
spring.session.jdbc.table-name=SPRING_SESSION
#   用于存储会话的集合名称。
spring.session.mongo.collection-name=session
#   Sessions flush模式。
spring.session.redis.flush-mode=on-save
#   用于存储会话的密钥的命名空间。
spring.session.redis.namespace=namespace
#   会话存储类型。
spring.session.store-type=redis



#   启用支持的提供程序的连接状态视图。
spring.social.auto-connection-views=false
#   您的应用程序的Facebook应用程序ID
spring.social.facebook.app-id=app-id
#   您的应用程序的Facebook应用程序秘密
spring.social.facebook.app-secret=app-secret
#   您的应用程序的LinkedIn应用程序ID
spring.social.linkedin.app-id=app-id
#   您的应用程序的LinkedIn应用程序秘密
spring.social.linkedin.app-secret=app-secret
#   你的应用程序的Twitter应用程序ID
spring.social.twitter.app-id=app-id
#   你的应用程序的Twitter应用程序秘密
spring.social.twitter.app-secret=app-secret




#   启用模板缓存。
spring.thymeleaf.cache=true
#   在渲染之前检查模板是否存在。
spring.thymeleaf.check-template-location=true
#   检查模板位置是否存在。
spring.thymeleaf.check-template=true
#   Content-Type值。
spring.thymeleaf.content-type=text/html
#   启用MVC Thymeleaf视图分辨率。
spring.thymeleaf.enabled=true
#   模板编码。
spring.thymeleaf.encoding=UTF-8
#   应该从解决方案中排除的视图名称的逗号分隔列表
spring.thymeleaf.excluded-view-names=namers
#   应用于模板的模板模式。另请参见StandardTemplateModeHandlers。
spring.thymeleaf.mode=HTML5
#   在构建URL时预先查看名称的前缀
spring.thymeleaf.prefix=classpath:/templates/
#   构建URL时附加查看名称的后缀
spring.thymeleaf.suffix=.html
#   链中模板解析器的顺序。
spring.thymeleaf.template-resolver-order=orders
#   可以解析的视图名称的逗号分隔列表。
spring.thymeleaf.view-names=names




#   默认事务超时（以秒为单位）。
spring.transaction.default-timeout=1000
#   在提交失败时执行回滚。
spring.transaction.rollback-on-commit-failure=true




#   作为服务的基本URI的路径。
spring.webservices.path=/services/
#   将Servlet init参数传递给Spring Web Services。
spring.webservices.servlet.init.xxx=xxx
#   加载Spring Web Services servlet的启动优先级。
spring.webservices.servlet.load-on-startup=-1



#
spring.test.database.replace=any
spring.test.mockmvc.print=default


#
spring.datasource.dbcp2.time-between-eviction-runs-millis=1000
spring.datasource.dbcp2.enable-auto-commit-on-return=true
spring.datasource.dbcp2.num-tests-per-eviction-run=1
spring.datasource.dbcp.time-between-eviction-runs-millis=10000
spring.datasource.dbcp.num-tests-per-eviction-run=1
#server.port=5000
#security.basic.path=/**
#security.user.password=password
#server.context-path=path
#server.error.path=/error
#server.context-parameters.xxx=xxx
#server.servlet-path=/
#server.session.persistent=false
#server.ssl.protocol=ssl
#server.tomcat.port-header=X-Forwarted-fox
#sp


#   Server
#   在重新启动之间持续会话数据。
server.session.persistent=false
#   主调度程序servlet的路径。
server.servlet-path=.
#   Servlet上下文初始化参数。例如`server.context-parameters.a = alpha`
server.context-parameters.xx=xx
#   错误控制器的路径
server.error.path=/error
#   应用程序的上下文路径。
server.context-path=/
#   erver HTTP端口。
server.port=80
#   服务器应绑定到的网络地址。
server.address=localhost
#   是否启用响应压缩。
server.compression.enabled=true
#   从压缩中排除的用户代理列表。
server.compression.excluded-user-agents=agentr
#   应该压缩的MIME类型的逗号分隔列表
server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript
#   执行压缩所需的最小响应大小。
server.compression.min-response-size=100
#   连接器在关闭连接之前等待另一个HTTP请求的时间（以毫秒为单位）。未设置时，将使用连接器的容器特定默认值。使用-1表示no（即无限）超时。
server.connection-timeout=1000
#   显示名称
server.display-name=application
#   何时包含“stacktrace”属性。
server.error.include-stacktrace=never
#   在服务器发生错误的情况下，启用浏览器中显示的默认错误页面。
server.error.whitelabel.enabled=true
#   要使用的接受者线程数。
server.jetty.acceptors=100
#   HTTP发布或放置内容的最大大小（以字节为单位）。
server.jetty.max-http-post-size=0
#   要使用的选择器线程数。
server.jetty.selectors=100
#   JSP servlet的类名
server.jsp-servlet.class-name=org.apache.catalina.servlets.CGIServlet
#   用于配置JSP servlet的Init参数
server.jsp-servlet.init-parameters.xx=xxx
#   否注册了JSP servlet
server.jsp-servlet.registered=true
#   Server HTTP端口。
server.max-http-header-size=0
#   用于服务器响应头的值（没有头发送为空）
server.server-header=header
#   注释会话cookie。
server.session.cookie.comment=comment
#   会话cookie的域。
server.session.cookie.domain=xxx.com
#   “HttpOnly”标志为会话cookie。
server.session.cookie.http-only=true
#   会话cookie的最大年龄（以秒为单位）。
server.session.cookie.max-age=100
#   会话cookie名称。
server.session.cookie.name=zr_
#   会话cookie的路径。
server.session.cookie.path=/
#   “Secure”标志为会话cookie。
server.session.cookie.secure=true
#   用于存储会话数据的目录。
server.session.store-dir=dir
#   会话超时（秒）。
server.session.timeout=10000
#   会话跟踪模式（以下一个或多个：“cookie”，“url”，“ssl”）。
server.session.tracking-modes=mode




#   支持的SSL密码。
server.ssl.ciphers=xx
#   客户端认证是否需要（“想”）或需要（“需要”）。需要信托商店。
server.ssl.client-auth=need
#   启用SSL支持。
server.ssl.enabled=true
#   启用SSL协议。
server.ssl.enabled-protocols=ssl
#   标识密钥库中的密钥的别名。
server.ssl.key-alias=ssl
#   用于访问密钥库中的密钥的密码。
server.ssl.key-password=password
#   保存SSL证书（通常是jks文件）的密钥存储区的路径。
server.ssl.key-store=store
#   用于访问密钥库的密码。
server.ssl.key-store-password=password
#   密钥存储的提供者。
server.ssl.key-store-provider=pro
#   密钥存储的类型。
server.ssl.key-store-type=cache
#   SSL协议使用。
server.ssl.protocol=ssl
#   保存SSL证书的Trust存储。
server.ssl.trust-store=xx
#   用于访问信任存储的密码。
server.ssl.trust-store-password=password
#   信任存储的提供程序。
server.ssl.trust-store-provider=pro
#   信任存储的类型。
server.ssl.trust-store-type=redis




#   用于覆盖原始端口值的HTTP头的名称。
server.tomcat.port-header=X-Forwarded-Port
#   所有可能的请求处理线程正在使用时，传入连接请求的最大队列长度
server.tomcat.accept-count=0
#   缓冲区输出，只能周期性地刷新
server.tomcat.accesslog.buffered=true
#   创建日志文件的目录。可以相对于tomcat base dir或absolute。
server.tomcat.accesslog.directory=logs
#   启用访问日志。
server.tomcat.accesslog.enabled=false
#   要在日志文件名中放置的日期格式。
server.tomcat.accesslog.file-date-format=.yyyy-mm-dd
#   访问日志的格式化模式。
server.tomcat.accesslog.pattern=common
#   日志文件名前缀。
server.tomcat.accesslog.prefix=access_log
#   将文件名中的日期戳推迟到旋转时间。
server.tomcat.accesslog.rename-on-rotate=false
#   设置请求的IP地址，主机名，协议和端口的请求属性。
server.tomcat.accesslog.request-attributes-enabled=false
#   启用访问日志轮换。
server.tomcat.accesslog.rotate=true
#   日志文件名后缀。
server.tomcat.accesslog.suffix=.log
#   与逗号分隔的列表，其中匹配要忽略TLD扫描的jar。
server.tomcat.additional-tld-skip-patterns=patt
#   在调用backgroundProcess方法之间以秒为单位的延迟。
server.tomcat.background-processor-delay=30
#   Tomcat基本目录。如果未指定，将使用临时目录。
server.tomcat.basedir=dir
#   正则表达式匹配可信IP地址。
server.tomcat.internal-proxies=10.\\d{1,3}.\\d{1,3}.\\d{1,3}|.192.168\\d{1,3}\\d{1,3}|.169\\254\\d{1,3}\\d{1,3}|.127\\d{1,3}\\d{1,3}\\d{1,3}|172\\1[6-9]{1}\\d{1,3}\\d{1,3}|..\\172\\2[0-9]{1}\\d{1,3}\\d{1,3} |..\\172.3[0-1]{1}.\\d{1,3}.\\d{1,3}
#   服务器在任何给定时间接受和处理的最大连接数。
server.tomcat.max-connections=0
#   TTP帖子内容的最大大小（以字节为单位）。
server.tomcat.max-http-post-size=0
#   最大工作线程数。
server.tomcat.max-threads=0
#   最小工作线程数。
server.tomcat.min-spare-threads=0
#   标题，保存传入协议，通常命名为“X-Forwarded-Proto”。
server.tomcat.protocol-header=header
#   指示传入请求使用SSL的协议头的值。
server.tomcat.protocol-header-https-value=https
#   通过在路径上附加/重定向到上下文根的请求。
server.tomcat.redirect-context-root=true
#   提取远程ip的HTTP头的名称。例如`X-FORWARDED-FOR`
server.tomcat.remote-ip-header=header
#   用于解码URI的字符编码。
server.tomcat.uri-encoding=UTF-8





#   访问日志目录
server.undertow.accesslog.dir=dir
#   启用访问日志。
server.undertow.accesslog.enabled=true
#   访问日志的格式模式。
server.undertow.accesslog.pattern=common
#   日志文件名前缀。
server.undertow.accesslog.prefix=access_log.
#   启用访问日志轮换。
server.undertow.accesslog.rotate=true
#   日志文件名后缀。
server.undertow.accesslog.suffix=log
#   每个缓冲区的大小（以字节为单位）。
server.undertow.buffer-size=1000
#   在Java堆之外分配缓冲区。
server.undertow.direct-buffers=true
#   为工作者创建的I / O线程数。
server.undertow.io-threads=10
#   HTTP帖子内容的最大大小（以字节为单位）。
server.undertow.max-http-post-size=0
#   工作线程数。
server.undertow.worker-threads=10
#   如果X-Forwarded- *头应该应用于HttpRequest。
server.use-forward-headers=true
#
server.max-http-post-size=0
#
server.undertow.buffers-per-region=1




#security
#   安全授权模式申请。
security.basic.authorize-mode=role
#   为所有请求启用安全通道。
security.require-ssl=false
#   HTTP基本的领域名称。
security.basic.realm=Spring
#   为默认用户名授予角色。
security.user.role=xxx
#   用于验证令牌的过滤器链的顺序。
security.oauth2.resource.filter-order=0
#   资源的标识符
security.oauth2.resource.id=id
#   获取可用于验证令牌的密钥集的URI。
security.oauth2.resource.jwk.key-set-uri=uri
#   JWT令牌的URI。如果值不可用并且密钥是公共的，可以设置。
security.oauth2.resource.jwt.key-uri=uri
#   JWT令牌的验证密钥。可以是对称秘密或PEM编码的RSA公钥。
security.oauth2.resource.jwt.key-value=value
#   使用令牌信息，可以设置为false以使用用户信息。
security.oauth2.resource.prefer-token-info=true
#
security.oauth2.resource.service-id=resource
#   令牌解码端点的URI。
security.oauth2.resource.token-info-uri=uri
#   使用userInfoUri时发送的令牌类型。
security.oauth2.resource.token-type=auth
#   用户端点的URI。
security.oauth2.resource.user-info-uri=uri
#
security.oauth2.authorization.realm=ca
#
security.oauth2.client.refresh-token-validity-seconds=30
#
security.oauth2.client.registered-redirect-uri=uri
#
security.oauth2.client.resource-ids=ids
#
security.oauth2.client.pre-established-redirect-uri=str
#   默认用户名的密码。默认情况下，启动时会记录随机密码
security.user.password=pass
#   安全路径的逗号分隔列表。
security.basic.path=/**
#   启用基本身份验证
security.basic.enabled=true
#   启用跨站点请求伪造支持
security.enable-csrf=false
#   安全过滤器链调度程序类型。
security.filter-dispatcher-types=ASYNC,FORWARD,INCLUDE,REQUEST
#   安全过滤器连锁订单。
security.filter-order=0
#   启用缓存控制HTTP头。
security.headers.cache=true
#   内容安全策略头的值。
security.headers.content-security-policy=xx
#   内容安全策略模式。
security.headers.content-security-policy-mode=default
#   启用“X-Content-Type-Options”头。
security.headers.content-type=true
#   启用“X-Frame-Options”标题。
security.headers.frame=true
#   HTTP严格传输安全（HSTS）模式（无，域，全部）
security.headers.hsts=all
#   启用跨站点脚本（XSS）保护。
security.headers.xss=true
#   从默认安全路径中排除的路径的逗号分隔列表。
security.ignored=xxx
#
security.oauth2.authorization.check-token-access=xxx
#
security.oauth2.authorization.token-key-access=xx
#   OAuth2 client id。
security.oauth2.client.client-id=1
#   OAuth2客户机密码。默认生成随机密码
security.oauth2.client.client-secret=2
#   如果不提供显式的WebSecurityConfigurerAdapter
security.oauth2.sso.filter-order=1
#   的应用过滤顺序登录页面的路径，即一个这将触发重定向到OAuth2授权服务器
security.oauth2.sso.login-path=/login
#   会话创建策略（永远不会，if_required，无状态）。
security.sessions=stateless
#   默认用户名。
security.user.name=user
#
security.oauth2.client.access-token-uri=uri
security.oauth2.client.access-token-validity-seconds=30
security.oauth2.client.additional-information.xx=xx
security.oauth2.client.authentication-scheme=xx
security.oauth2.client.authorities=xx
spring.activemq.pool.configuration.time-between-expiration-check-millis=10000
security.oauth2.client.authorized-grant-types=xx
security.oauth2.client.auto-approve-scopes=xxx
security.oauth2.client.client-authentication-scheme=xx
security.oauth2.client.grant-type=xx
security.oauth2.client.id=id
security.oauth2.client.scope=xx
security.oauth2.client.token-name=xx
security.oauth2.client.use-current-uri=true
security.oauth2.client.user-authorization-uri=xx
spring.datasource.dbcp2.eviction-policy-class-name=xx
spring.datasource.dbcp2.log-expired-connections=true
#encrypt.key-store.secret=xx
#eureka.client.eureka-connection-idle-timeout-seconds=30

#encrypt
#   秘密保护密钥（默认为密码相同）
encrypt.key-store.secret=xx
#   标记说，如果存在加密或解密错误，进程将失败。
encrypt.fail-on-error=true
#   对称密钥。作为一个更强大的替代方案，考虑使用密钥库。
encrypt.key=A
#   商店中的钥匙别名
encrypt.key-store.alias=xx
#   密钥存储文件的位置，例如classpath：/keystore.jks。
encrypt.key-store.location=classpath:/keystore.jks
#   锁定密钥库的密码。
encrypt.key-store.password=pass
#   使用RSA算法（DEFAULT或OEAP）。一旦设置不改变它（或现有的密码将不可解密）。
encrypt.rsa.algorithm=default
#   Salt用于加密密文的随机秘密。一旦设置不改变它（或现有的密码将不可解密）。
encrypt.rsa.salt=deadbeef
#   标志表示应该在内部使用“强”AES加密。如果为真，则将GCM算法应用于AES加密字节。默认值为false（在这种情况下使用“标准”CBC代替）。一旦设置不改变它（或现有的密码将不可解密）
encrypt.rsa.strong=false



#   启用端点
endpoints.actuator.enabled=false
#   Endpoint URL路径。
endpoints.actuator.path=/**
#   在端点上启用安全性。
endpoints.actuator.sensitive=false
#   启用端点。
endpoints.auditevents.enabled=false
#   端点路径。
endpoints.auditevents.path=/**
#   在端点上启用安全性。
endpoints.auditevents.sensitive=false
#   启用端点。
endpoints.autoconfig.enabled=false
#   端点标识符。
endpoints.autoconfig.id=id
#   端点路径。
endpoints.autoconfig.path=/
#   标记端点是否公开敏感信息。
endpoints.autoconfig.sensitive=false
#   启用端点。
endpoints.beans.enabled=false
#   端点标识符。
endpoints.beans.id=1
#   端点路径。
endpoints.beans.path=/
#   标记端点是否公开敏感信息。
endpoints.beans.sensitive=false
#   启用端点。
endpoints.configprops.enabled=false
#   端点标识符。
endpoints.configprops.id=1
#   应该消毒的密钥。键可以是属性结束的简单字符串或正则表达式。
endpoints.configprops.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services
#   端点路径。
endpoints.configprops.path=/
#   标记端点是否公开敏感信息。
endpoints.configprops.sensitive=false
#   设置是否支持凭据。未设置时，不支持凭据。
endpoints.cors.allow-credentials=false
#   在请求中允许的头文件的逗号分隔列表。'*'允许所有标题
endpoints.cors.allowed-headers=*
#   逗号分隔的允许的方法列表。'*'允许所有方法。
endpoints.cors.allowed-methods=GET
#   允许的逗号分隔的起始列表。'*'允许所有来源。未设置时，禁用CORS支持。
endpoints.cors.allowed-origins=*
#   包含在响应中的标题的逗号分隔列表。
endpoints.cors.exposed-headers=xx
#   客户端可以缓存飞行前请求的响应时间（秒）。
endpoints.cors.max-age=1800
#   启用居里生成。
endpoints.docs.curies.enabled=false
#   启用执行文档端点。
endpoints.docs.enabled=false
#   文档路径
endpoints.docs.path=/docs
#   标记文档信息
endpoints.docs.sensitive=false
#   启用端点。
endpoints.dump.enabled=false
#   端点标识符。
endpoints.dump.id=1
#   端点路径。
endpoints.dump.path=/
#   标记端点是否公开敏感信息。
endpoints.dump.sensitive=false
#   启用端点。
endpoints.enabled=false
#   启用端点。
endpoints.env.enabled=false
#   端点标识符
endpoints.env.id=1
#   应该消毒的密钥。键可以是属性结束的简单字符串或正则表达式。
endpoints.env.keys-to-sanitize=password,secret,key,token,.*credentials.*,vcap_services
#   端点路径。
endpoints.env.path=/
#
endpoints.env.post.enabled=false
#   标记端点是否公开敏感信息。
endpoints.env.sensitive=false
#
endpoints.features.enabled=false
endpoints.features.id=1
endpoints.features.sensitive=false
#   启用端点。
endpoints.flyway.enabled=false
#   端点标识符
endpoints.flyway.id=1
#   标记端点是否公开敏感信息。
endpoints.flyway.sensitive=false
#   启用端点。
endpoints.health.enabled=false
#   端点标识符。
endpoints.health.id=1
#   将健康状态映射到HTTP状态代码。默认情况下，注册健康状态映射到明智的默认值（即UP映射到200）。
endpoints.health.mapping.xxx=xxx
#   端点路径。
endpoints.health.path=.
#   标记端点是否公开敏感信息。
endpoints.health.sensitive=false
#   缓存结果的生存时间，以毫秒为单位。
endpoints.health.time-to-live=1000
#   启用端点。
endpoints.heapdump.enabled=false
#   端点路径
endpoints.heapdump.path=/
#   标记端点是否公开敏感信息
endpoints.heapdump.sensitive=false
#   启用端点的超媒体支持。
endpoints.hypermedia.enabled=false
#
endpoints.id=1
#   启用端点
endpoints.info.enabled=false
#   端点标识符。
endpoints.info.id=1
#   端点路径。
endpoints.info.path=/
#   标记端点是否公开敏感信息。
endpoints.info.sensitive=false
#   JMX域名。如果设置为'spring.jmx.default-domain'的值初始化。
endpoints.jmx.domain=xxx.com
#   启用所有端点的JMX导出。
endpoints.jmx.enabled=true
#   附加静态属性以附加到表示端点的MBean的所有对象
endpoints.jmx.static-names.xx=xx
#   确保在发生冲突时修改ObjectNames。
endpoints.jmx.unique-names=false
#   启用Jolokia终结点。
endpoints.jolokia.enabled=false
#   jolokia ＃端点URL路径。
endpoints.jolokia.path=/
#   在端点上启用安全性。
endpoints.jolokia.sensitive=false
#   启用端点。
endpoints.liquibase.enabled=false
#   端点标识符。
endpoints.liquibase.id=1
#   标记端点是否公开敏感信息。
endpoints.liquibase.sensitive=false
#   启用端点。
endpoints.logfile.enabled=false
#   要访问的外部日志文件。
endpoints.logfile.external-file=x
#   端点URL路径。
endpoints.logfile.path=/
#   在端点上启用安全性。
endpoints.logfile.sensitive=false
#   启用端点。
endpoints.loggers.enabled=false
#   端点标识符。
endpoints.loggers.id=1
#   端点路径。
endpoints.loggers.path=/logfile
#   标记端点是否公开敏感信息。
endpoints.loggers.sensitive=false
#   启用端点。
endpoints.mappings.enabled=false
#   端点标识符。
endpoints.mappings.id=1
#端点路径。
endpoints.mappings.path=/
#   标记端点是否公开敏感信息。
endpoints.mappings.sensitive=false
#   启用端点。
endpoints.metrics.enabled=false
#   Http过滤器规范提交（合并，每个http方法）
endpoints.metrics.filter.counter-submissions=merged
#   启用度量servlet过滤器。
endpoints.metrics.filter.enabled=false
#   Http过滤器计数器提交（合并，每个http方法）
endpoints.metrics.filter.gauge-submissions=merged
#   端点标识符。
endpoints.metrics.id=1
#   端点路径。
endpoints.metrics.path=/
#   标记端点是否公开敏感信息。
endpoints.metrics.sensitive=false
#   启用端点
endpoints.pause.enabled=false
#   端点标识符。
endpoints.pause.id=1
#   标记端点是否公开敏感信息。
endpoints.pause.sensitive=false
#
endpoints.refresh.enabled=false
endpoints.refresh.id=1
endpoints.refresh.sensitive=false
endpoints.restart.enabled=true
#
endpoints.restart.id=1
endpoints.restart.pause-endpoint.enabled=true
endpoints.restart.pause-endpoint.id=1
endpoints.restart.pause-endpoint.sensitive=true
endpoints.restart.resume-endpoint.enabled=true
endpoints.restart.resume-endpoint.id=1
endpoints.restart.resume-endpoint.sensitive=true
endpoints.restart.sensitive=true
endpoints.restart.timeout=0
#
endpoints.resume.enabled=true
endpoints.resume.id=1
endpoints.resume.sensitive=true
#
endpoints.routes.enabled=true
endpoints.routes.id=1
endpoints.routes.sensitive=true
#   默认端点敏感设置。
endpoints.sensitive=true
#   启用端点。
endpoints.shutdown.enabled=true
#   端点标识符。
endpoints.shutdown.id=1
#   端点路径。
endpoints.shutdown.path=/
#   标记端点是否公开敏感信息。
endpoints.shutdown.sensitive=true
#   启用端点。
endpoints.trace.enabled=true
#   启用跟踪servlet过滤器。
endpoints.trace.filter.enabled=true
#   端点标识符。
endpoints.trace.id=1
#   端点路径。
endpoints.trace.path=/
#   标记端点是否公开敏感信息。
endpoints.trace.sensitive=true

#   https://www.hellojava.com/a/73153.html
#eureka
#   该服务实例的命名空间,用于查找属性
eureka.instance.namespace=eureka
#   http通信端口
eureka.instance.non-secure-port=80
#   http通信端口是否启用
eureka.instance.non-secure-port-enabled=true
#   instance之间复制数据时可以重试的次数
eureka.server.number-of-replication-retries=5
#   这是一个瞬态配置，一旦最新的编解码器稳定，可以删除（因为只有一个）
#   这是一个短暂的×××的配置，如果最新的×××是稳定的，则可以去除，默认为null
eureka.client.decoder-name=name
#   这是一个瞬态配置，一旦最新的编解码器稳定，可以删除（因为只有一个）
#   这是一个短暂的编码器的配置，如果最新的编码器是稳定的，则可以去除，默认为null
eureka.client.encoder-name=name
#   eureka对等节点间连接超时时间
eureka.server.peer-node-connect-timeout-ms=200
#   eureka对等节点连接后的空闲时间
eureka.server.peer-node-connection-idle-timeout-seconds=30
#   节点间的读数据连接超时时间
eureka.server.peer-node-read-timeout-ms=200
#   eureka server 节点间连接的总共最大数量
eureka.server.peer-node-total-connections=1000
#   eureka server 节点间连接的单机最大数量
eureka.server.peer-node-total-connections-per-host=500
#   获取代理用户名（如果有）。
eureka.client.proxy-user-name=xxx
#   获取要在eureka中注册的应用程序组的名称。 注册在Eureka服务中的应用组名
eureka.instance.app-group-name=xx
#   每分钟续约次数
eureka.instance.registry.expected-number-of-renews-per-min=1
#   该实例的虚拟主机名称(http)
eureka.instance.virtual-host-name=unknow
#   json的转换的实现类名
eureka.server.json-codec-name=name
#   eureka节点间间隔多长时间更新一次数据。默认10分钟。
eureka.server.peer-eureka-nodes-update-interval-ms=600000
#   eureka server xml的编解码实现名称
eureka.server.xml-codec-name=name
#   表示到eureka服务器的HTTP连接可以在关闭之前保持空闲状态的时间（以秒为单位）。
#   在AWS环境中，建议值为30秒或更短，因为防火墙在几分钟内清除连接信息，将连接挂在空中
eureka.client.eureka-connection-idle-timeout-seconds=1
#   获取要查询的DNS名称以获取eureka服务器的列表。如果合同通过实现serviceUrls返回服务URL，则不需要此信息。
#   当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。
#   更改在运行时有效。
eureka.client.eureka-server-d-n-s-name=name
#   指示在连接到eureka服务器需要超时之前等待（以秒为单位）的时间。请注意，客户端中的连接由org.apache.http.client.HttpClient汇集，
#   此设置会影响实际的连接创建以及从池中获取连接的等待时间
eureka.client.eureka-server-connect-timeout-seconds=30
#   指示服务器是否可以将客户端请求重定向到备份服务器/集群。
#   如果设置为false，服务器将直接处理请求，如果设置为true，则可能会向客户端发送HTTP重定向，并具有新的服务器位置。
eureka.client.allow-redirects=true
#   获取此实例所在区域的可用性区域列表（用于AWS数据中心）。更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效。
eureka.client.availability-zones.xx=xx
#   获取执行BackupRegistry的实现的名称，以便仅在eureka客户端启动时首次将注册表信息作为回退选项提取。
#   对于需要额外的弹性的注册表信息的应用程序可能需要这一点，而无法运行它们
eureka.client.backup-registry-impl=impl
#   缓存刷新执行者指数退出相关属性。在发生超时序列的情况下，它是重试延迟的最大乘数值。
eureka.client.cache-refresh-executor-exponential-back-off-bound=10
#   cacheRefreshExecutor初始化的线程池大小
eureka.client.cache-refresh-executor-thread-pool-size=2
#   EurekaAccept客户端数据接受名称
eureka.client.client-data-accept=cx
#   指示eureka客户端是否应该禁用提取delta，而应该诉诸于获取完整的注册表信息。
#   请注意，增量获取可以极大地减少流量，因为尤利卡服务器的更改速率通常远低于提取速率。
#   更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效
eureka.client.disable-delta=false
#   在eureka服务器的序列化/反序列化信息期间，获取Dollar符号<code> $ </ code>的替换字符串。
eureka.client.dollar-replacement=_-
#   获取实例所在的地区下可用性的区域列表，用逗号隔开。（AWS）
eureka.client.availability-zones.xxx=xxx
#   标记以指示启用Eureka客户端。
eureka.client.enabled=false
#   在eureka服务器的序列化/反序列化信息期间获取下划线符号<code> _ </ code>的替换字符串。
eureka.client.escape-char-replacement=__
#   获取用于构建服务url的端口，以在eureka服务器列表来自DNS时联系eureka服务器。如果合同返回服务url eurekaServerServiceUrls（String），则不需要此信息。
#   当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。
#   更改在运行时有效。
eureka.client.eureka-server-port=20000
#   指示从eureka服务器读取之前需要等待（秒）多久才能超时。
eureka.client.eureka-server-read-timeout-seconds=8
#   获取从eureka客户端到所有eureka服务器允许的总连接数。
eureka.client.eureka-server-total-connections=200
#   获取从eureka客户端到eureka服务器主机允许的总连接数。
eureka.client.eureka-server-total-connections-per-host=50
#   获取用于构建服务网址的URL上下文，以便在eureka服务器列表来自DNS时联系eureka服务器。如果合同从eurekaServerServiceUrls返回服务网址，则不需要此信息。
#   当useDnsForFetchingServiceUrls设置为true时，使用DNS机制，而eureka客户端希望DNS以某种方式配置，以便可以动态获取更改的eureka服务器。更改在运行时有效。
eureka.client.eureka-server-u-r-l-context=xxx
#   表示轮询对eureka服务器信息进行更改的频率（以秒为单位）。可以添加或删除Eureka服务器，此设置控制eureka客户端应该知道的时间。
eureka.client.eureka-service-url-poll-interval-seconds=0
#   指示该客户端是否应从eureka服务器获取eureka注册表信息。
eureka.client.fetch-registry=true
#   逗号分隔将获取eureka注册表信息的区域列表。必须为availabilityZones返回的每个区域定义可用性区域。否则，将导致发现客户端启动失败。
eureka.client.fetch-remote-regions-registry=s
#   指示是否在仅具有InstanceStatus UP状态的实例的过滤应用程序之后获取应用程序。
eureka.client.filter-only-up-instances=true
#   指示从服务器支持时，是否必须压缩从eureka服务器提取的内容。来自eureka服务器的注册表信息被压缩以获得最佳的网络流量。
eureka.client.g-zip-content=true
#   心跳执行者指数回撤相关财产。在发生超时序列的情况下，它是重试延迟的最大乘数值。
eureka.client.heartbeat-executor-exponential-back-off-bound=10
#   heartbeat执行器初始化的线程池大小
eureka.client.heartbeat-executor-thread-pool-size=2
#   指示将实例信息复制到eureka服务器的开始时间（以秒为单位）
eureka.client.initial-instance-info-replication-interval-seconds=40
#   指示复制要复制到eureka服务器的实例更改的频率（以秒为单位）。
eureka.client.instance-info-replication-interval-seconds=30
#   指示在注册表信息方面是否记录eureka服务器和eureka客户端之间的差异。
#   Eureka客户端尝试仅从欧莱雅服务器检索增量更改以最小化网络流量。收到三角形后，eureka客户端将从服务器的信息进行协调，以验证它是否已经没有漏掉一些信息。
#   当客户端发生网络问题与服务器通信时，可能会发生调解失败。如果对帐失败，eureka客户端将获得完整的注册表信息。
#   在获取完整的注册表信息的同时，eureka客户端可以记录客户端和服务器之间的差异，并且此设置控制它。
#   更改在运行时在registryFetchIntervalSecondsr指定的下一个注册表提取周期中有效
eureka.client.log-delta-diff=false
#   如果设置为true，则通过ApplicationInfoManager进行的本地状态更新将触发对远程eureka服务器的按需（但限速）注册/更新
eureka.client.on-demand-update-status-change=true
#   指示此实例是否应尝试在同一区域中使用尤里卡服务器延迟和/或其他原因
#   理想情况下，eureka客户端配置为与同一区域中的服务器通信
#   更改在运行时在registryFetchIntervalSeconds指定的下一个注册表提取周期中有效。
eureka.client.prefer-same-zone-eureka=true
#   属性解释器
eureka.client.property-resolver=xx
#   获取代理主机到eureka服务器（如果有的话）。
eureka.client.proxy-host=localhost
#   获取代理密码（如果有）。
eureka.client.proxy-password=password
#   获取代理端口到eureka服务器（如果有的话）
eureka.client.proxy-port=33333
#   获取此实例所在的区域（用于AWS数据中心）
eureka.client.region=us-east-1
#   指示此实例是否应将其信息注册到eureka服务器以供其他人发现。
#   在某些情况下，您不希望实例被发现，而您只想发现其他实例。
#   如本地测试
eureka.client.register-with-eureka=true
#   指示从eureka服务器获取注册表信息的频率（以秒为单位）。
eureka.client.registry-fetch-interval-seconds=30
#   指示客户端是否只对单个VIP的注册表信息感兴趣。
eureka.client.registry-refresh-single-vip-address=true
#   可用性区域映射到与eureka服务器通信的完全限定URL的列表。每个值可以是单个URL或逗号分隔的替代位置列表。
#   通常，尤里卡服务器URL携带协议，主机，端口，上下文和版本信息（如果有的话）。示例：http : //ec2-256-156-243-129.compute-1.amazonaws.com : 7001/eureka/
#   更改在运行时在eurekaServiceUrlPollIntervalSeconds指定的下一个服务网址刷新周期中有效。
eureka.client.service-url.xx=xx
#   指示eureka客户端是否应该使用DNS机制来获取要与之通信的eureka服务器列表。当DNS名称更新为具有其他服务器时，该信息将在eureka客户端轮询该
#   eurka​​ServiceUrlPollIntervalSeconds中指定的信息之后立即使用。
#   或者，服务urls可以返回serviceUrls，但用户应该实现自己的机制来返回更新的列表，以防发生更改。
#   更改在运行时有效。
eureka.client.use-dns-for-fetching-service-urls=false
#   标志以启用Eureka仪表板。默认值为true。
eureka.dashboard.enabled=true
#   到Eureka仪表板（相对于servlet路径）的路径。默认为“/”。
eureka.dashboard.path=/
#   获取与此实例关联的AWS自动缩放组名称。该信息在AWS环境中专门用于在实例启动后自动将实例停止运行，并且已将其禁用。
#   用于AWS平台自动扩展的与此实例关联的组名，
eureka.instance.a-s-g-name=name
#   获取要在eureka注册的应用程序的名称。 注册在的Eureka服务中的应用名称
eureka.instance.appname=unknown
#   返回此实例部署的数据中心。如果实例部署在AWS中，则此信息用于获取一些AWS特定实例信息。
#   部署此实例的数据中心
eureka.instance.data-center-info=info
#   默认的地址解析顺序
eureka.instance.default-address-resolution-order=[]
#   该实例的环境配置
eureka.instance.environment=test
#   获取此实例的绝对运行状况检查页面URL。如果运行状况检查页面驻留在与eureka通话的同一个实例中，用户可以提供healthCheckUrlPath，
#   否则在实例是其他服务器的代理的情况下，用户可以提供完整的URL。如果提供完整的URL，则优先。
#   它通常用于根据实例的健康状况做出有根据的决策 - 例如，它可用于确定是否继续部署到整个场，或者停止部署而不会造成进一步的损坏。完整的URL应遵循格式
#   该实例健康检查url,绝对路径
eureka.instance.health-check-url=localhost
#   该实例健康检查url,相对路径
eureka.instance.health-check-url-path=/health
#   该实例的主页url,绝对路径
eureka.instance.home-page-url=xxx
#   该实例的主页url,相对路径
eureka.instance.home-page-url-path=/
eureka.instance.host-info=localhost
#   服务注册中心实例的主机名
eureka.instance.hostname=localhost
eureka.instance.inet-utils=xxx
#   初始化该实例，注册到服务中心的初始状态
eureka.instance.initial-status=down
#   表明是否只要此实例注册到服务中心，立马就进行通信
eureka.instance.instance-enabled-onit=false
#   该实例注册到服务中心的唯一ID
eureka.instance.instance-id=id
#   该实例的IP地址
eureka.instance.ip-address=xxx
#   服务中心删除此服务实例的等待时间(秒为单位),时间间隔为最后一次服务中心接受到的心跳时间
eureka.instance.lease-expiration-duration-in-seconds=90
#   该实例给服务中心发送心跳的间隔时间，用于表明该服务实例可用
eureka.instance.lease-renewal-interval-in-seconds=30
#   该服务实例的子定义元数据，可以被服务中心接受到
eureka.instance.metadata-map.test=test
#   该实例，相较于hostname是否优先使用IP
eureka.instance.prefer-ip-address=false
#   该实例，注册服务中心，默认打开的通信数量
eureka.instance.registry.default-open-for-traffic-count=1
#   该实例的安全健康检查url,绝对路径
eureka.instance.secure-health-check-url=xxx
#   https通信端口
eureka.instance.secure-port=443
#   https通信端口是否启用
eureka.instance.secure-port-enabled=false
#   该实例的安全虚拟主机名称(https)
eureka.instance.secure-virtual-host-name=unknown
#   该实例的状态呈现url,绝对路径
eureka.instance.status-page-url=xx
#   该实例的状态呈现url,相对路径
eureka.instance.status-page-url-path=/status
#   缓存ASG信息的过期时间。
eureka.server.a-s-g-cache-expiry-timeout-ms=0
#   查询ASG信息的超时时间
eureka.server.a-s-g-query-timeout-ms=300
#   服务更新ASG信息的频率
eureka.server.a-s-g-update-interval-ms=0
#   AWS访问ID
eureka.server.a-w-s-access-id=xx
#   AWS安全密钥
eureka.server.a-w-s-secret-key=xxx
#   指示群集节点之间的复制是否应批处理以提高网络效率。
eureka.server.batch-replication=false
#   AWS绑定策略
eureka.server.binding-strategy=route53
#   间隔多长时间，清除过期的delta数据
eureka.server.delta-retention-timer-interval-in-ms=0
#   过期数据，是否也提供给client
eureka.server.disable-delta=false
#   期数据，是否也提供给远程region
eureka.server.disable-delta-for-remote-regions=false
#   回退到远程区域中的应用程序的旧行为 (如果已配置) 如果本地区域中没有该应用程序的实例, 则将被禁用。
eureka.server.disable-transparent-fallback-to-other-region=false
#   服务端尝试绑定候选EIP的次数
eureka.server.e-i-p-bind-rebind-retries=3
#   服务端绑定EIP的时间间隔.如果绑定就检查;如果绑定失效就重新绑定。当且仅当已经绑定的情况
eureka.server.e-i-p-binding-retry-interval-ms=10
#   服务端绑定EIP的时间间隔.当且仅当服务为绑定的情况
eureka.server.e-i-p-binding-retry-interval-ms-when-unbound=0
#   发送复制数据是否在request中，总是压缩
eureka.server.enable-replicated-request-compression=false
#   服务端开启自我保护模式。无论什么情况，服务端都会保持一定数量的服务。避免client与server的网络问题，而出现大量的服务被清除。
eureka.server.enable-self-preservation=true
#   开启清除无效服务的定时任务，时间间隔。默认1分钟
eureka.server.eviction-interval-timer-in-ms=60000
#   指示在服务器支持的情况下, 是否必须为远程区域压缩从尤里卡服务器获取的内容。
eureka.server.g-zip-content-from-remote-region=true
#   用于从第三方AWS 帐户描述自动扩展分组的角色的名称。
eureka.server.list-auto-scaling-groups-role-name=ListAuto
#   eureka服务端是否记录client的身份header
eureka.server.log-identity-headers=true
#   允许备份到备份池的最大复制事件数量。而这个备份池负责除状态更新的其他事件。可以根据内存大小，超时和复制流量，来设置此值得大小
eureka.server.max-elements-in-peer-replication-pool=10000
#   允许备份到状态备份池的最大复制事件数量
eureka.server.max-elements-in-status-replication-pool=10000
#   多个服务中心相互同步信息线程的最大空闲时间
eureka.server.max-idle-thread-age-in-minutes-for-peer-replication=15
#   状态同步线程的最大空闲时间
eureka.server.max-idle-thread-in-minutes-age-for-status-replication=10
#   服务注册中心各个instance相互复制数据的最大线程数量
eureka.server.max-threads-for-peer-replication=20
#   服务注册中心各个instance相互复制状态数据的最大线程数量
eureka.server.max-threads-for-status-replication=1
#   instance之间复制数据的通信时长
eureka.server.max-time-for-replication=30000
#   正常的对等服务instance最小数量。-1表示服务中心为单节点。
eureka.server.min-available-instances-for-peer-replication=-1
#   instance之间相互复制开启的最小线程数量
eureka.server.min-threads-for-peer-replication=5
#   instance之间用于状态复制，开启的最小线程数量
eureka.server.min-threads-for-status-replication=1
#   eureka服务状态的相互更新的时间间隔。
eureka.server.peer-eureka-status-refresh-time-interval-ms=0
#   是否应该建立连接引导
eureka.server.prime-aws-replica-connections=true
#   PropertyResolver
eureka.server.property-resolver=xxx
#   请求频率限制器
eureka.server.rate-limiter-burst-size=10
#   是否开启请求频率限制器
eureka.server.rate-limiter-enabled=false
#   请求频率的平均值
eureka.server.rate-limiter-full-fetch-average-rate=100
#   设置信任的client list
eureka.server.rate-limiter-privileged-clients=xxx
#   注册服务、拉去服务列表数据的请求频率的平均值
eureka.server.rate-limiter-registry-fetch-average-rate=500
#   是否对标准的client进行频率请求限制。如果是false，则只对非标准client进行限制
eureka.server.rate-limiter-throttle-standard-clients=false
#   在服务节点启动时，eureka尝试获取注册信息的次数
eureka.server.registry-sync-retries=0
#   在服务节点启动时，eureka多次尝试获取注册信息的间隔时间
eureka.server.registry-sync-retry-wait-ms=0
#   remote region 应用白名单
eureka.server.remote-region-app-whitelist.xxx=xxx
#   连接eureka remote note的连接超时时间
eureka.server.remote-region-connect-timeout-ms=10000
#   连接eureka remote note的连接空闲时间
eureka.server.remote-region-connection-idle-timeout-seconds=30
#   执行remote region 获取注册信息的请求线程池大小
eureka.server.remote-region-fetch-thread-pool-size=20
#   remote region 从对等eureka加点读取数据的超时时间
eureka.server.remote-region-read-timeout-ms=10000
#   从remote region 获取注册信息的时间间隔
eureka.server.remote-region-registry-fetch-interval=30
#   remote region 连接eureka节点的总连接数量
eureka.server.remote-region-total-connections=1000
#   remote region 连接eureka节点的单机连接数量
eureka.server.remote-region-total-connections-per-host=500
#   remote region抓取注册信息的存储文件，而这个可靠的存储文件需要全限定名来指定
eureka.server.remote-region-trust-store=xxx
#   remote region 储存的文件的密码
eureka.server.remote-region-trust-store-password=changeit
#   remote region url.多个逗号隔开
eureka.server.remote-region-urls=xxxx
#   remote region url.多个逗号隔开
eureka.server.remote-region-urls-with-name.name=xxx
#   在设置的时间范围类，期望与client续约的百分比。
eureka.server.renewal-percent-threshold=0.85
#   多长时间更新续约的阈值
eureka.server.renewal-threshold-update-interval-ms=0
#   对于缓存的注册数据，多长时间过期
eureka.server.response-cache-auto-expiration-in-seconds=180
#   多长时间更新一次缓存中的服务注册数据
eureka.server.response-cache-update-interval-ms=0
#   缓存增量数据的时间，以便在检索的时候不丢失信息
eureka.server.retention-time-in-m-s-in-delta-queue=0
#   服务端尝试绑定route53的次数
eureka.server.route53-bind-rebind-retries=3
#   服务端间隔多长时间尝试绑定route53
eureka.server.route53-binding-retry-interval-ms=0
#
eureka.server.route53-domain-t-t-l=30
#   当时间戳不一致的时候，是否进行同步
eureka.server.sync-when-timestamp-differs=true
#   是否采用只读缓存策略，只读策略对于缓存的数据不会过期。
eureka.server.use-read-only-response-cache=true
#   当eureka server启动的时候，不能从对等节点获取instance注册信息的情况，应等待多长时间。
eureka.server.wait-time-in-ms-when-sync-empty=0



# logging
#   日志文件的位置。例如`/ var / log`
logging.path=/
#   记录配置文件的位置。例如对于Logback logging的`classpath：logback.xml`
logging.config=xx
#   记录异常时使用的转换字。
logging.exception-conversion-word=%wEx
#   记录文件名。例如`myapp.log`
logging.file=xx
#   日志级别严重性映射。例如`logging.level.org.springframework = DEBUG`
logging.level.root = debug
#   用于输出到控制台的Appender模式。只支持默认的logback设置。
logging.pattern.console=%clr
#   用于输出到文件的Appender模式。只支持默认的logback设置。
logging.pattern.file=%d
#   日志级别的Appender模式（默认％5p）。只支持默认的logback设置
logging.pattern.level=debug
#   记录系统初始化时注册一个关闭挂钩。
logging.register-shutdown-hook=true



#   在每个响应中添加“X-Application-Context”HTTP头。
management.add-application-context-header=true
#   管理端点应绑定到的网络地址。
management.address=xxx
#   启用扩展的Cloud Foundry执行端点
management.cloudfoundry.enabled=true
#   跳过SSL验证的Cloud Foundry执行端点安全要求
management.cloudfoundry.skip-ssl-validation=false
#   管理端点上下文路径。例如`/ actuator`
management.context-path=/
#   启用cassandra健康检查。
management.health.cassandra.enabled=true
#   启用couchbase健康检查。
management.health.couchbase.enabled=true
management.health.db.enabled=true
#   启用数据库运行状况检查。
management.health.defaults.enabled=true
#   启用diskspace运行状况检查。
management.health.diskspace.enabled=true
#   用于计算可用磁盘空间的路径。
management.health.diskspace.path=/
#   应该可用的最小磁盘空间（以字节为单位）。
management.health.diskspace.threshold=0
#   启用弹性搜索健康检查。
management.health.elasticsearch.enabled=true
#   逗号分隔的索引名称。
management.health.elasticsearch.indices=xxx
#   等待群集响应的时间（以毫秒为单位）
management.health.elasticsearch.response-timeout=100
#   启用JMS运行状况检查。
management.health.jms.enabled=true
#   启用LDAP运行状况检查。
management.health.ldap.enabled=true
#   启用邮件运行状况检查。
management.health.mail.enabled=true
#   启用mongo运行状况检查。
management.health.mongo.enabled=true
#   启用rabbit运行状况检查。
management.health.rabbit.enabled=true
#   启用redis运行状况检查。
management.health.redis.enabled=true
#   启用refresh运行状况检查。 启用刷新范围的运行状况端点。
management.health.refresh.enabled=true
#management.health.zookeeper.enabled=启用zookeeper的健康端点。
#   启用solr运行状况检查。
management.health.solr.enabled=true
#   按照
management.health.status.order=DOWN,OUT_OF_SERVICE,UP,UNKNOWN
#   启用构建信息。
management.info.build.enabled=true
#   启用默认的信息贡献者。
management.info.defaults.enabled=true
#   启用环境信息。
management.info.env.enabled=true
#   启用git信息。
management.info.git.enabled=true
#   使用暴露git信息的模式。simple
management.info.git.mode=full
#   管理端点HTTP端口。默认使用与应用程序相同的端口。配置不同的端口以使用特定于管理的SSL。
management.port=80
#   启用安全性。
management.security.enabled=true
#   逗号分隔的可以访问管理端点的角色列表。
management.security.roles=ACTUATOR
#   会话创建策略使用（总是，从不，if_required，无状态）。
management.security.sessions=stateless
#   JAAS域。
management.shell.auth.jaas.domain=xxx.com
#   验证密钥的路径。这应该指向一个有效的“.pem”文件。
management.shell.auth.key.path=/
#   登录用户。
management.shell.auth.simple.user.name=user
#   登录密码
management.shell.auth.simple.user.password=pass
#   登录到CRaSH控制台所需的角色的逗号分隔列表。
management.shell.auth.spring.roles=ACTUATOR
#   验证类型。根据环境自动检测
management.shell.auth.type=simple
#   用户被提示再次登录后的毫秒数
management.shell.ssh.auth-timeout=600000
#   启用CRaSH SSH支持。
management.shell.ssh.enabled=true
#   未使用的连接关闭之后的毫秒数
management.shell.ssh.idle-timeout=600000
#   SSH服务器密钥的路径。
management.shell.ssh.key-path=/
#   SSH端口。
management.shell.ssh.port=2000
#   启用CRaSH telnet支持。如果TelnetPlugin可用，默认情况下启用。
management.shell.telnet.enabled=false
#   Telnet端口
management.shell.telnet.port=5000
#   支持的SSL密码。需要一个自定义的管理
management.ssl.ciphers=xx
#   客户端认证是否需要（“想”）或需要（“需要”）。需要信托商店。需要一个自定义的管理。
management.ssl.client-auth=need
#   启用SSL支持。需要一个自定义的管理。
management.ssl.enabled=false
#   启用SSL协议。需要一个自定义的管理。
management.ssl.enabled-protocols=ssl
#   标识密钥库中的密钥的别名。需要一个自定义的管理。
management.ssl.key-alias=xx
#   用于访问密钥库中的密钥的密码。需要一个自定义的管理。
management.ssl.key-password=pass
#   保存SSL证书（通常是jks文件）的密钥存储库的路径。需要一个自定义的管理。
management.ssl.key-store=xx
#   密码用于访问密钥库。需要一个自定义的管理。
management.ssl.key-store-password=pass
#   密钥存储的提供者。需要一个自定义的管理。
management.ssl.key-store-provider=xx
#   密钥存储的类型。需要一个自定义的管理。
management.ssl.key-store-type=xx
#   SSL协议使用。需要一个自定义的管理。
management.ssl.protocol=xx
#   保存SSL证书的Trust存储。需要一个自定义的管理。
management.ssl.trust-store=xx
#   用于访问信任存储的密码。需要一个自定义的管理。
management.ssl.trust-store-password=xx
#   信托商店的提供商。需要一个自定义的管理。
management.ssl.trust-store-provider=xx
#   信任存储的类型。需要一个自定义的管理。
management.ssl.trust-store-type=xx
#   要包含在跟踪中的项目。
management.trace.include=request-headers,response-headers,cookies,errors


#   mybatis
#   https://www.jianshu.com/p/cdb309e2a209
#   当检测到无法匹配的属性时，如何执行。NONE，什么也不做。WARNING，打印警告日志。FAILING，失败抛异常
mybatis-plus.configuration.auto-mapping-unknown-column-behavior=none
#   指定如何自动映射到对象的字段、属性。NONE，不映射。PARTIAL，除了内嵌属性其余的进行映射。FULL ，全映射，包含内嵌属性。
mybatis-plus.configuration.auto-mapping-behavior=PARTIAL
#   和lazyLoadingEnabled配合使用。lazyLoadingEnabled为true时，aggressiveLazyLoading为true则加载所有懒加载对象，为false则按需加载懒加载对象 false (true in ≤3.4.1)
mybatis-plus.configuration.aggressive-lazy-loading=false
mybatis-plus.check-config-location=false
mybatis-plus.config-location=localhost
mybatis-plus.configuration-properties.xx=xx
mybatis-plus.configuration.cache-enabled=false
mybatis-plus.configuration.cache-names=names
mybatis-plus.configuration.caches=true
#   当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，
#   这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的
mybatis-plus.configuration.call-setters-on-nulls=false
#   自定义生成Configuration的类，返回的Configuration的实例用于加载反序列化对象的懒加载属性，该类必须有static Configuration getConfiguration()方法
mybatis-plus.configuration.configuration-factory=java.lang.Object
mybatis-plus.configuration.database-id=xx
#   执行器类型，SIMPLE是普通的执行器；REUSE执行器会重用预处理语句(prepared statements)；BATCH执行器将重用语句并执行批量更新，注意事项请查看附录3
mybatis-plus.configuration.default-executor-type=SIMPLE
#   设置最大的抓取数量，会被query方法上设置的覆盖
mybatis-plus.configuration.default-fetch-size=10
#   SQL执行超时时间
mybatis-plus.configuration.default-statement-timeout=1000
mybatis-plus.configuration.environment=test
mybatis-plus.configuration.incomplete-cache-refs=refs
mybatis-plus.configuration.incomplete-methods=post
mybatis-plus.configuration.incomplete-result-maps=xx
mybatis-plus.configuration.incomplete-statements=xx
mybatis-plus.configuration.interceptors=xx
#   没有指定jdbcType的参数，其返回值为NULL时，指定 jdbcType。 某些驱动需要指定jdbcType，其他驱动直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。
#   JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER
mybatis-plus.configuration.jdbc-type-for-null=OTHER
mybatis-plus.configuration.key-generator-names=xx
mybatis-plus.configuration.key-generators=xx
#   指定某些方法懒加载
#   方法名组成的列表，方法名之间中逗号分隔
mybatis-plus.configuration.lazy-load-trigger-methods=equals,clone,hashCode,toString
#   主要是级联时使用，全局开启/关闭懒加载，如果配置为true，所有关联对象都会被加载。fetchType配置会覆盖全局配置
mybatis-plus.configuration.lazy-loading-enabled=false
#   一级缓存，mybatis利用本地缓存来防止重复查询、加速重复的内嵌查询。默认的作用域是Session，一次回话中的所有查询都会被缓存。
#   当作用域是STATEMENT时，本地缓存仅作用域语句执行上，即便是同一会话的不同的调用，也不会有任何数据会共享
#   SESSION/STATEMENT
mybatis-plus.configuration.local-cache-scope=session
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
# 	指定 MyBatis 增加到日志名称的前缀
mybatis-plus.configuration.log-prefix=zr_
#   是否开启自动驼峰命名规则
mybatis-plus.configuration.map-underscore-to-camel-case=false
mybatis-plus.configuration.mapped-statement-names=xx
mybatis-plus.configuration.mapped-statements=xx
#   允许/不允许一条SQL返回多个结果集，具体情形请查看附录1
mybatis-plus.configuration.multiple-result-sets-enabled=false
mybatis-plus.configuration.object-factory=xx
mybatis-plus.configuration.object-wrapper-factory=xx
mybatis-plus.configuration.parameter-map-names=name
mybatis-plus.configuration.parameter-maps=xx
#  	创建懒加载对象时用到的代理工具类
#   CGLIB/JAVASSIST
mybatis-plus.configuration.proxy-factory=JAVASSIST
#
mybatis-plus.configuration.reflector-factory=xx
mybatis-plus.configuration.result-map-names=xx
mybatis-plus.configuration.result-maps=xx
#   Mybatis，当结果集为NULL的时候返回null。如果设置为true，Mybatis会返回一个空的实例。内置的集合（collection、association）也会返回空的对象实例（3.4.2+）
mybatis-plus.configuration.return-instance-for-empty-row=false
#   允许在嵌套语句中使用分页（ResultHandler）
mybatis-plus.configuration.safe-result-handler-enabled=true
#   允许在嵌套语句中使用分页(RowBounds)
mybatis-plus.configuration.safe-row-bounds-enabled=false
mybatis-plus.configuration.sql-fragments.xx=xx
#   允许SQL语句中使用mapper接口声明的变量名称，前提是你的项目是用Java编译的，并且在mapper接口的方法上使用@param
mybatis-plus.configuration.use-actual-param-name=true
#   使用列索引号代替列名称
mybatis-plus.configuration.use-column-label=true
#   允许JDBC 生成主键。需要可兼容的驱动器。如果配置为true，将强制使用被生成的主键，不兼容的驱动器仍然执行。
mybatis-plus.configuration.use-generated-keys=false
mybatis-plus.configuration.variables.xx=xx
#   指定VFS的实现类
#   自定义类的全路径，用逗号分隔。
mybatis-plus.configuration.vfs-impl=org.apache.ibatis.io.DefaultVFS
#   执行器类型，SIMPLE是普通的执行器；REUSE执行器会重用预处理语句(prepared statements)；BATCH执行器将重用语句并执行批量更新，注意事项请查看附录3
mybatis-plus.executor-type=SIMPLE
#  是否大写命名
mybatis-plus.global-config.capital-mode=true 
#   是否使用下划线命名
mybatis-plus.global-config.db-column-underline=true
#   字段验证策略
mybatis-plus.global-config.field-strategy=0
#   主键类型
mybatis-plus.global-config.id-type=0
#   标识符
mybatis-plus.global-config.identifier-quote=xx
#   逻辑删除全局值
mybatis-plus.global-config.logic-delete-value=0
#   逻辑未删除全局值
mybatis-plus.global-config.logic-not-delete-value=1
#   是否动态刷新mapper
mybatis-plus.global-config.refresh-mapper=true
#   缓存SQL解析初始化
mybatis-plus.global-config.sql-parser-cache=true
mybatis-plus.mapper-locations=xxx
mybatis-plus.type-aliases-package=xxx
#   自定义枚举包
mybatis-plus.type-enums-package=xxx

mybatis-plus.type-handlers-package=xxx
#   表关键词生成器
mybatis-plus.global-config.key-generator=xxx
#   元字段填充控制器
mybatis-plus.global-config.meta-object-handler=xx
#   sql注入器
mybatis-plus.global-config.sql-injector=xxx


# feign
#   支持的MIME类型列表。
feign.compression.request.mime-types=text/html
#   最小阈值内容大小。
feign.compression.request.min-request-size=2048

# ribbon
#   我们在使用Spring Cloud的Ribbon或Feign来实现服务调用的时候，如果我们的机器或网络环境等原因不是很好的话，有时候会发现这样一个问题：
#   我们服务消费方调用服务提供方接口的时候，第一次请求经常会超时，而之后的调用就没有问题了。下面我们就来说说造成这个问题的原因，以及如何解决的方法。
#   造成第一次服务调用出现失败的原因主要是Ribbon进行客户端负载均衡的Client并不是在服务启动的时候就初始化好的，而是在调用的时候才会去创建相应的Client，
#   所以第一次调用的耗时不仅仅包含发送HTTP请求的时间，
#   还包含了创建RibbonClient的时间，这样一来如果创建时间速度较慢，同时设置的超时时间又比较短的话，很容易就会出现上面所描述的显现。
#   而Feign的实现基于Ribbon，所以它也有一样的问题，下面就来看看如何解决这个问题。
#   解决的方法很简单，既然第一次调用时候产生RibbonClient耗时，那么就让它提前创建，而不是在第一次调用的时候创建。
#   在Spring Cloud的Dlaston版本中提供了几个新的参数，它们可以很方便的帮我们实现这样的功能。
#   通过上面的配置完成之后，我们尝试重启一下服务消费者，这个时候我们会发现，我们没有开始调用服务接口，但是上面初始化负载均衡的日志就已经打印出来了。
#   这就说明我们对ribbon的饥饿加载模块设置已经生效了。
#   指定需要饥饿加载的客户端名称、服务名
ribbon.eager-load.clients=hello-service, user-service
#   开启Ribbon的饥饿加载模式
ribbon.eager-load.enabled=false

# hystrix
#   启用Hystrix指标轮询。默认为true。
hystrix.metrics.enabled=true
#   后续轮询度量之间的间隔。默认为2000 ms。
hystrix.metrics.polling-interval-ms=2000

#   zuul
#   标识以确定代理是否转发主机头。
zuul.add-host-header=false
#   标识以确定代理是否添加X-Forwarded- *标头。
zuul.add-proxy-headers=true
zuul.force-original-query-string-encoding=false
zuul.host.connect-timeout-millis=2000
#   单个路由可以使用的最大连接数。
zuul.host.max-per-route-connections=20
#   代理可以容纳到后端的总连接数。
zuul.host.max-total-connections=200
#
zuul.host.socket-timeout-millis=100000
zuul.host.time-to-live=-1
zuul.host.time-unit=days
zuul.ignore-local-service=true
#   标记说，如果spring security在类路径上，则将SECURITY_HEADERS添加到忽略的标头。通过将ignoreSecurityHeaders设置为false，我们可以关闭此默认行为。
#   这应该与禁用默认的spring security标头一起使用，
#   请参见https://docs.spring.io/spring-security/site/docs/current/reference/html/headers.html#default-security-headers
zuul.ignore-security-headers=true
#   HTTP标头的名称完全忽略（即将其从下游请求中删除，并将其从下游响应中删除）
zuul.ignored-headers=xx
zuul.ignored-patterns=xx
#   一组服务名称不考虑代理自动。默认情况下，发现客户端中的所有服务都将被代理
zuul.ignored-services=xx
#   所有路由的公共前缀。
zuul.prefix=xx
#   标记说，可以删除超过第一个分号的路径元素。
zuul.remove-semicolon-content=true
#   默认情况下是否支持重试的标志（假设路由本身支持）
zuul.retryable=false
#
zuul.ribbon-isolation-strategy=semaphore
#   将路线名称映射到属性
zuul.routes.xx=xx
#   zuul.securityheaders，一般预期由Spring安全性添加的标头，因此如果代理和后端使用Spring保护，则通常会重复。默认情况下，如果存在Spring安全性，并且ignoreSecurityHeaders = true，它们将被添加到忽略的标头。
zuul.s-e-c-u-r-i-t-y-h-e-a-d-e-r-s=xx
#   Hystrix的总信号量的最大数量。
zuul.semaphore.max-semaphores=100
#   不传递到下游请求的敏感标头列表。默认为通常包含用户凭据的“安全”标题集。如果下游服务是与代理相同的系统的一部分，那么从列表中删除它们是正确的，所以他们正在共享认证数据。如果在您自己的域之外使用物理URL，那么一般来说泄漏用户凭据将是一个坏主意。
zuul.sensitive-headers=xx
#   安装Zuul作为servlet的路径（不是SpringMVC的一部分）。对于具有大型机构的请求，例如文件上传，servlet对于更高的内存效率更高。
zuul.servlet-path=/zuul
#   标记以说明是否应验证ssl连接的主机名。默认值为true。这只应用于测试设置
zuul.ssl-hostname-validation-enabled=true
#   在转发之前标记是否从路径中删除前缀。
zuul.strip-prefix=true
#   标记说可以跟踪请求机构。
zuul.trace-request-body=true


#   flyway
#   检查迁移脚本位置是否存在。
flyway.check-location=false
#   启用飞行路线。
flyway.enabled=true
#   执行SQL语句以获取后立即初始化连接。
flyway.init-sqls=xx
#   迁移脚本的位置
flyway.locations=classpath:db/migration
#   如果要让Flyway 创建自己的DataSource，请输入JDBC密码
#   目标数据库的密码.
flyway.password=pass
#   要迁移的数据库的JDBC url。如果未设置，则使用主配置的数据源。
flyway.url=xx
#   登录要迁移的数据库的用户。
flyway.user=user
#   对执行迁移时基准版本的描述
flyway.baseline-description=xx
#   当迁移时发现目标schema非空，而且带有没有元数据的表时，是否自动执行基准迁移，默认false.
flyway.baseline-on-migrate=true
#   开始执行基准迁移时对现有的schema的版本打标签，默认值为1.
flyway.baseline-version=1.0.0
#   当发现校验错误时是否自动调用clean，默认false
flyway.clean-on-validation-error=true
#   设置迁移时的编码，默认UTF-8.
flyway.encoding=UTF-8
#   当读取元数据表时是否忽略错误的迁移，默认false.
flyway.ignore-failed-future-migration=true
#   是否允许无序的迁移，默认false.
flyway.out-of-order=true
#   设置每个placeholder的前缀，默认${
flyway.placeholder-prefix=zr_
#   placeholders是否要被替换，默认true
flyway.placeholder-replacement=true
#   设置每个placeholder的后缀，默认}
flyway.placeholder-suffix=zr_
#   设置placeholder的value
flyway.placeholders.xx=xx
#   设定需要flywary迁移的schema，大小写敏感，默认为连接默认的schema.
flyway.schemas=xx
#   迁移文件的前缀，默认为V
flyway.sql-migration-prefix=zr_
#   迁移脚本的文件名分隔符，默认__
flyway.sql-migration-separator=xx
#   迁移脚本的后缀，默认为.sql
flyway.sql-migration-suffix=xx
#   flyway使用的元数据表名，默认为schema_version
flyway.table=xx
#   迁移时使用的目标版本，默认为latest version
flyway.target=xx
#   迁移时是否校验，默认为true
flyway.validate-on-migrate=true
#flyway.ini
#flyway.placeholders.xx=xx
flyway.init-description=xx
flyway.init-on-migrate=true
flyway.init-version=1.0.0

#netflix
netflix.atlas.batch-size=10000
netflix.atlas.enabled=true
netflix.atlas.uri=xxx
#   当ServoMonitorCache达到这个大小时，会记录一个警告。如果您在RestTemplate url中使用字符串连接，这将非常有用。
netflix.metrics.servo.cache-warning-threshold=1000
#   Servo使用的监视器注册表的完全限定类名
netflix.metrics.servo.registry-class=com.netflix.servo.BasicMonitorRegistry


#   banner
#   横幅文件编码
banner.charset=UTF-8
#   字符中横幅图像的高度（基于图像高度默认）
banner.image.height=100
#   如果图像应该为暗终端主题反转（默认为false）
banner.image.invert=false
#   横幅图像文件位置（也可以使用jpg / png）
banner.image.location=banner.gif
#   左手图像边距在chars（默认2）
banner.image.margin=0
#   在字符中横幅图像的宽度（默认76）
banner.image.width=100
#   横幅文件位置。
banner.location=classpath*:

#   是否开启debug
debug=false
#   是否开启追踪
trace=false
#   是否开启info
info.xx=xx
#   见Jolokia手册
jolokia.config.xxx=xxx
#   更改日志配置路径。
liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml
#   使用逗号分隔的运行时上下文列表。
liquibase.contexts=xxx
#   检查更改日志位置是否存在。
liquibase.check-change-log-location=true
#   默认数据库模式。
liquibase.default-schema=xxx
#   首先删除数据库模式
liquibase.drop-first=false
#   启用liquidibase支持。
liquibase.enabled=true
#   使用逗号分隔的运行时标签列表。
liquibase.labels=xxx
#   更改日志参数。
liquibase.parameters.xxx=xxx
#   登录要迁移的数据库的密码。
liquibase.password=xxx
#   执行更新时要写入哪个回滚SQL的文件。
liquibase.rollback-file=xxx
#   要迁移的数据库的JDBC url。如果未设置，则使用主配置的数据源。
liquibase.url=xxx
#   登录要迁移的数据库的用户。
liquibase.user=xx
#   https://cloud.tencent.com/developer/article/1041355

#   标记以指示应安装配置服务器运行状况指示器。
health.config.enabled=false
#   生成缓存结果的时间，以毫秒为单位。默认300000（5分钟）。
health.config.time-to-live=0

